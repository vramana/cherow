(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.cherow = {})));
}(this, (function (exports) { 'use strict';

/* DO NOT edit this file unless you know what you are doing.
 * A little change here can  *blow up* the entire parser!
 */
// Note: this *must* be kept in sync with the enum's order.
//
// It exploits the enum value ordering, and it's necessarily a complete and
// utter hack.
//
// All to lower it to a single monomorphic array access.
var KeywordDescTable = [
    'end of source',
    /* Constants/Bindings */
    'identifier', 'number', 'string', 'regular expression',
    'false', 'true', 'null',
    /* Template nodes */
    'template continuation', 'template end',
    /* Punctuators */
    '=>', '(', '{', '.', '...', '}', ')', ';', ',', '[', ']', ':', '?', '\'', '"', '</', '/>',
    /* Update operators */
    '++', '--',
    /* Assign operators */
    '=', '<<=', '>>=', '>>>=', '**=', '+=', '-=', '*=', '/=', '%=', '^=', '|=',
    '&=',
    /* Unary/binary operators */
    'typeof', 'delete', 'void', '!', '~', '+', '-', 'in', 'instanceof', '*', '%', '/', '**', '&&',
    '||', '===', '!==', '==', '!=', '<=', '>=', '<', '>', '<<', '>>', '>>>', '&', '|', '^',
    /* Variable declaration kinds */
    'var', 'let', 'const',
    /* Other reserved words */
    'break', 'case', 'catch', 'class', 'continue', 'debugger', 'default', 'do', 'else', 'export',
    'enum', 'extends', 'finally', 'for', 'function', 'if', 'import', 'new', 'return', 'super', 'switch',
    'this', 'throw', 'try', 'while', 'with',
    /* Strict mode reserved words */
    'implements', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield',
    /* Contextual keywords */
    'as', 'async', 'await', 'constructor', 'get', 'set', 'from', 'of',
    /* Special */
    'arguments', 'eval',
    /* Stage 3 */
    '#', '@', 'BigInt',
    /* TypeScript / Flow */
    'declare', 'type', 'opaque', '{|', '|}', 'mixins', 'checks', 'module', 'exports',
    /* TypeScript */
    'keyof', 'is', 'readonly',
    /* JSX */
    'JSXText'
];
/**
 * The conversion function between token and its string description/representation.
 */
function tokenDesc(token) {
    return KeywordDescTable[token & 255 /* Type */];
}
// Used `Object.create(null)` to avoid potential `Object.prototype`
// interference.
var DescKeywordTable = Object.create(null, {
    as: { value: 69740 /* AsKeyword */ },
    async: { value: 33624173 /* AsyncKeyword */ },
    await: { value: 134418542 /* AwaitKeyword */ },
    break: { value: 12362 /* BreakKeyword */ },
    case: { value: 12363 /* CaseKeyword */ },
    catch: { value: 12364 /* CatchKeyword */ },
    class: { value: 143437 /* ClassKeyword */ },
    const: { value: 143433 /* ConstKeyword */ },
    constructor: { value: 69743 /* ConstructorKeyword */ },
    continue: { value: 12366 /* ContinueKeyword */ },
    debugger: { value: 12367 /* DebuggerKeyword */ },
    default: { value: 12368 /* DefaultKeyword */ },
    delete: { value: 1191979 /* DeleteKeyword */ },
    do: { value: 12369 /* DoKeyword */ },
    else: { value: 12370 /* ElseKeyword */ },
    export: { value: 12371 /* ExportKeyword */ },
    enum: { value: 12372 /* EnumKeyword */ },
    extends: { value: 12373 /* ExtendsKeyword */ },
    false: { value: 143365 /* FalseKeyword */ },
    finally: { value: 12374 /* FinallyKeyword */ },
    for: { value: 12375 /* ForKeyword */ },
    from: { value: 69746 /* FromKeyword */ },
    function: { value: 143448 /* FunctionKeyword */ },
    get: { value: 69744 /* GetKeyword */ },
    if: { value: 12377 /* IfKeyword */ },
    implements: { value: 20580 /* ImplementsKeyword */ },
    import: { value: 143450 /* ImportKeyword */ },
    in: { value: 669489 /* InKeyword */ },
    instanceof: { value: 669490 /* InstanceofKeyword */ },
    interface: { value: 20581 /* InterfaceKeyword */ },
    let: { value: 151624 /* LetKeyword */ },
    new: { value: 143451 /* NewKeyword */ },
    null: { value: 143367 /* NullKeyword */ },
    of: { value: 69747 /* OfKeyword */ },
    package: { value: 20582 /* PackageKeyword */ },
    private: { value: 20583 /* PrivateKeyword */ },
    protected: { value: 20584 /* ProtectedKeyword */ },
    public: { value: 20585 /* PublicKeyword */ },
    return: { value: 12380 /* ReturnKeyword */ },
    set: { value: 69745 /* SetKeyword */ },
    static: { value: 20586 /* StaticKeyword */ },
    super: { value: 143453 /* SuperKeyword */ },
    switch: { value: 143454 /* SwitchKeyword */ },
    this: { value: 143455 /* ThisKeyword */ },
    throw: { value: 12384 /* ThrowKeyword */ },
    true: { value: 143366 /* TrueKeyword */ },
    try: { value: 12385 /* TryKeyword */ },
    typeof: { value: 1191978 /* TypeofKeyword */ },
    var: { value: 143431 /* VarKeyword */ },
    void: { value: 1191980 /* VoidKeyword */ },
    while: { value: 12386 /* WhileKeyword */ },
    with: { value: 12387 /* WithKeyword */ },
    yield: { value: 268587115 /* YieldKeyword */ },
    eval: { value: 25297013 /* Eval */ },
    arguments: { value: 25297012 /* Arguments */ },
    declare: { value: 16777337 /* DeclareKeyword */ },
    type: { value: 16777338 /* TypeKeyword */ },
    opaque: { value: 16777339 /* OpaqueKeyword */ },
    mixins: { value: 16777342 /* MixinsKeyword */ },
    checks: { value: 16777343 /* ChecksKeyword */ },
    module: { value: 16777344 /* ModuleKeyword */ },
    exports: { value: 16777345 /* ExportsKeyword */ },
    keyof: { value: 16777345 /* KeyOfKeyword */ },
    is: { value: 16777346 /* IsKeyword */ },
    readonly: { value: 16777347 /* ReadOnlyKeyword */ }
});
function descKeyword(value) {
    return (DescKeywordTable[value] | 0);
}

var ErrorMessages = {};
ErrorMessages[0 /* Unexpected */] = 'Unexpected token';
ErrorMessages[1 /* UnexpectedToken */] = 'Unexpected token %0';
ErrorMessages[2 /* BadGetterArity */] = "Getter functions must have no arguments";
ErrorMessages[3 /* BadSetterArity */] = 'Setter function must have exactly one argument';
ErrorMessages[4 /* BadSetterRestParameter */] = 'Setter function argument must not be a rest parameter';
ErrorMessages[5 /* NoCatchOrFinally */] = 'Missing catch or finally after try';
ErrorMessages[6 /* NewlineAfterThrow */] = 'Illegal newline after throw';
ErrorMessages[7 /* ParamAfterRest */] = 'Rest parameter must be last formal parameter';
ErrorMessages[8 /* InvalidDuplicateArgs */] = 'Duplicate binding %0';
ErrorMessages[9 /* MisingFormal */] = 'Missing formal parameter';
ErrorMessages[10 /* InvalidParameterAfterRest */] = 'Parameter after rest parameter';
ErrorMessages[11 /* LineBreakAfterAsync */] = 'No line break is allowed after async';
ErrorMessages[12 /* LineBreakAfterArrow */] = 'No line break is allowed after \'=>\'';
ErrorMessages[13 /* InvalidParenthesizedPattern */] = 'Invalid parenthesized pattern';
ErrorMessages[15 /* StrictFunction */] = 'In strict mode code, functions can only be declared at top level or inside a block';
ErrorMessages[17 /* SloppyFunction */] = 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement';
ErrorMessages[16 /* InvalidNestedStatement */] = '%0  statement must be nested within an iteration statement';
ErrorMessages[18 /* DisallowedInContext */] = '\'%0\' may not be used as an identifier in this context';
ErrorMessages[19 /* DuplicateProtoProperty */] = 'Property name __proto__ appears more than once in object literal';
ErrorMessages[116 /* ConstructorIsGenerator */] = 'Class constructor may not be a generator';
ErrorMessages[20 /* ConstructorSpecialMethod */] = 'Class member named constructor (or \'constructor\') may not be an accessor';
ErrorMessages[21 /* StaticPrototype */] = 'Classes may not have static property named prototype';
ErrorMessages[22 /* PrivateFieldConstructor */] = 'Classes may not have a private field named \'#constructor\'';
ErrorMessages[23 /* ConstructorClassField */] = 'Classes may not have a field named \'constructor\'';
ErrorMessages[24 /* DuplicateConstructor */] = 'A class may only have one constructor';
ErrorMessages[110 /* InvalidStaticField */] = 'Classes may not have a non-static field named \'%0\'';
ErrorMessages[25 /* ForbiddenAsStatement */] = '%0 can\'t appear in single-statement context';
ErrorMessages[26 /* StrictLHSPrefixPostFix */] = '%0 increment/decrement may not have eval or arguments operand in strict mode';
ErrorMessages[27 /* InvalidLhsInPrefixPostFixOp */] = 'Invalid left-hand side expression in %0 operation';
ErrorMessages[28 /* StrictDelete */] = 'Identifier expressions must not be deleted in strict mode';
ErrorMessages[29 /* StrictLHSAssignment */] = 'Eval or arguments can\'t be assigned to in strict mode code';
ErrorMessages[30 /* UnicodeOutOfRange */] = 'Unicode escape code point out of range';
ErrorMessages[32 /* StrictOctalEscape */] = 'Octal escapes are not allowed in strict mode';
ErrorMessages[33 /* InvalidEightAndNine */] = 'Escapes \\8 or \\9 are not syntactically valid escapes';
ErrorMessages[31 /* TemplateOctalLiteral */] = 'Template literals may not contain octal escape sequences';
ErrorMessages[34 /* InvalidHexEscapeSequence */] = 'Invalid hexadecimal escape sequence';
ErrorMessages[35 /* UnterminatedString */] = 'Unterminated string literal';
ErrorMessages[36 /* UnexpectedEscapedKeyword */] = 'Unexpected escaped keyword';
ErrorMessages[38 /* InvalidUnicodeEscapeSequence */] = 'Invalid Unicode escape sequence';
ErrorMessages[105 /* MissingUAfterSlash */] = '\'u\' was expected after \\';
ErrorMessages[37 /* UnexpectedSurrogate */] = 'Unexpected surrogate pair';
ErrorMessages[39 /* StrictOctalLiteral */] = 'Legacy octal literals are not allowed in strict mode';
ErrorMessages[40 /* InvalidRestBindingPattern */] = '`...` must be followed by an identifier in declaration contexts';
ErrorMessages[41 /* InvalidRestDefaultValue */] = 'Rest elements cannot have a default value';
ErrorMessages[42 /* ElementAfterRest */] = 'Rest elements cannot have a default value';
ErrorMessages[43 /* InitializerAfterRest */] = 'Rest elements cannot have a initializer';
ErrorMessages[44 /* StrictModeWith */] = 'Strict mode code may not include a with statement';
ErrorMessages[46 /* Redeclaration */] = 'Label \'%0\' has already been declared';
ErrorMessages[47 /* InvalidVarDeclInForLoop */] = 'Invalid variable declaration in for-%0 statement';
ErrorMessages[48 /* DeclarationMissingInitializer */] = 'Missing initializer in %0 declaration';
ErrorMessages[50 /* LetInLexicalBinding */] = 'let is disallowed as a lexically bound name';
ErrorMessages[51 /* InvalidStrictExpPostion */] = 'The identifier \'%0\' must not be in expression position in strict mode';
ErrorMessages[52 /* UnexpectedReservedWord */] = 'Unexpected reserved word';
ErrorMessages[53 /* InvalidGeneratorParam */] = 'Generator parameters must not contain yield expressions';
ErrorMessages[54 /* UnexpectedSuper */] = 'Member access from super not allowed in this context';
ErrorMessages[56 /* BadSuperCall */] = 'super() is not allowed in this context';
ErrorMessages[57 /* NewTargetArrow */] = 'new.target must be within function (but not arrow expression) code';
ErrorMessages[58 /* MetaNotInFunctionBody */] = 'new.target only allowed within functions';
ErrorMessages[59 /* IllegalReturn */] = 'Illegal return statement';
ErrorMessages[60 /* InvalidBindingStrictMode */] = 'The identifier \'%0\' must not be in binding position in strict mode';
ErrorMessages[61 /* InvalidAwaitInArrowParam */] = '\'await\' is not a valid identifier name in an async function';
ErrorMessages[62 /* UnNamedFunctionStmt */] = 'Function declaration must have a name in this context';
ErrorMessages[63 /* InvalidLHSInForLoop */] = 'Invalid left-hand side in for-loop';
ErrorMessages[64 /* ForInOfLoopMultiBindings */] = 'Invalid left-hand side in for-%0 loop: Must have a single binding.';
ErrorMessages[65 /* InvalidArrowYieldParam */] = 'Arrow parameters must not contain yield expressions';
ErrorMessages[66 /* IllegalUseStrict */] = 'Illegal \'use strict\' directive in function with non-simple parameter list';
ErrorMessages[67 /* InvalidLHSInAssignment */] = 'Invalid left-hand side in assignment';
ErrorMessages[68 /* AsyncFunctionInSingleStatementContext */] = 'Async functions can only be declared at the top level or inside a block';
ErrorMessages[69 /* ExportDeclAtTopLevel */] = 'Export declarations may only appear at top level of a module';
ErrorMessages[70 /* ImportDeclAtTopLevel */] = 'Import declarations may only appear at top level of a module';
ErrorMessages[45 /* UnknownLabel */] = 'Undefined label \'%0\'';
ErrorMessages[71 /* GeneratorLabel */] = 'Generator functions cannot be labelled';
ErrorMessages[75 /* DuplicateRegExpFlag */] = 'Duplicate regular expression flag %0';
ErrorMessages[74 /* UnexpectedNewlineRegExp */] = 'Regular expressions can not contain escaped newlines';
ErrorMessages[73 /* UnexpectedTokenRegExp */] = 'Unexpected regular expression';
ErrorMessages[76 /* UnexpectedTokenRegExpFlag */] = 'Unexpected regular expression flag';
ErrorMessages[72 /* UnterminatedRegExp */] = 'Unterminated regular expression literal';
ErrorMessages[77 /* UnterminatedComment */] = 'Unterminated MultiLineComment';
ErrorMessages[78 /* YieldInParameter */] = 'Yield expression not allowed in formal parameter';
ErrorMessages[79 /* InvalidNumericSeparators */] = 'Numeric separators are not allowed here';
ErrorMessages[80 /* InvalidBigIntLiteral */] = 'Invalid BigIntLiteral';
ErrorMessages[83 /* MissingBinaryDigits */] = 'Missing binary digits after \'0b\'';
ErrorMessages[82 /* MissingOctalDigits */] = 'Missing octal digits after \'0o\'';
ErrorMessages[81 /* MissingHexDigits */] = 'Missing hexadecimal digits after \'0x\'';
ErrorMessages[84 /* InvalidModuleSpecifier */] = 'Invalid module specifier';
ErrorMessages[85 /* NoAsAfterImportNamespace */] = 'Missing \'as\' keyword after import namespace';
ErrorMessages[86 /* MultipleDefaultsInSwitch */] = 'More than one default clause in switch statement';
ErrorMessages[87 /* UnterminatedTemplate */] = 'Unterminated template literal';
ErrorMessages[88 /* InvalidArrowConstructor */] = 'Arrow functions cannot be used as constructors';
ErrorMessages[89 /* InvalidDestructuringTarget */] = 'Invalid destructuring assignment target';
ErrorMessages[90 /* VariableExists */] = 'Identifier \'%0\' has already been declared!';
ErrorMessages[91 /* DuplicateParameter */] = 'Duplicate parameter \'%0\'';
ErrorMessages[14 /* UnexpectedStrictReserved */] = 'Unexpected strict mode reserved word';
ErrorMessages[92 /* UnexpectedStrictEvalOrArguments */] = 'Unexpected eval or arguments in strict mode';
ErrorMessages[93 /* BadImportCallArity */] = 'Dynamic import must have one specifier as an argument';
ErrorMessages[94 /* ArgumentsDisallowedInInitializer */] = '\'%0\' is not allowed in class field initializer';
ErrorMessages[95 /* InvalidCharacter */] = 'Invalid character \'%0\'';
ErrorMessages[96 /* InvalidDecimalWithLeadingZero */] = 'Decimal integer literals with a leading zero are forbidden in strict mode';
ErrorMessages[97 /* NonNumberAfterExponentIndicator */] = 'Invalid non-number after exponent indicator';
ErrorMessages[98 /* DuplicatePrivateName */] = 'Duplicate private name';
ErrorMessages[99 /* InvalidWhitespacePrivateName */] = 'Invalid whitespace after  \'#\'';
ErrorMessages[100 /* UnexpectedKeyword */] = 'Unexpected keyword \'%0\'';
ErrorMessages[101 /* NotAssignable */] = '\'%0\' is not a valid assignment left hand side';
ErrorMessages[102 /* NotBindable */] = '\'%0\' can not be treated as an actual binding pattern';
ErrorMessages[103 /* ComplexAssignment */] = 'A \'=\' was expected';
ErrorMessages[104 /* UnexpectedWSRegExp */] = 'Regular expressions can not contain whitespace';
ErrorMessages[55 /* LoneSuper */] = 'Only "(" or "." or "[" are allowed after \'super\'';
ErrorMessages[106 /* UndefinedUnicodeCodePoint */] = 'Undefined Unicode code-point';
ErrorMessages[107 /* InvalidOrUnexpectedToken */] = 'Invalid or unexpected token';
ErrorMessages[108 /* ForInOfLoopInitializer */] = '\'for-%0\' loop variable declaration may not have an initializer';
ErrorMessages[109 /* DeletePrivateField */] = 'Private fields can not be deleted';
ErrorMessages[111 /* InvalidPrivateFieldAccess */] = 'Invalid private field \'%0\'';
ErrorMessages[112 /* AwaitBindingIdentifier */] = '\'await\' is not a valid identifier name in an async function';
ErrorMessages[113 /* AwaitExpressionFormalParameter */] = 'Illegal await-expression in formal parameters of async function';
ErrorMessages[114 /* UnexpectedLexicalDeclaration */] = 'Lexical declaration cannot appear in a single-statement context';
ErrorMessages[115 /* ContinuousNumericSeparator */] = 'Only one underscore is allowed as numeric separator';
function constructError(msg, column) {
    var error = new Error(msg);
    try {
        throw error;
    }
    catch (base) {
        // istanbul ignore else
        if (Object.create && Object.defineProperty) {
            error = Object.create(base);
            Object.defineProperty(error, 'column', {
                enumerable: true,
                writable: true,
                value: column
            });
        }
    }
    // istanbul ignore next
    return error;
}
function createError(type, index, line, column, loc) {
    var params = [], len = arguments.length - 5;
    while ( len-- > 0 ) params[ len ] = arguments[ len + 5 ];

    if (loc) {
        index = loc.index;
        line = loc.line;
        column = loc.column;
    }
    var description = ErrorMessages[type].replace(/%(\d+)/g, function (_, i) { return params[i]; });
    var error = constructError(description + ' at ' + ':' + line + ':' + column, column);
    error.index = index;
    error.lineNumber = line;
    error.description = description;
    return error;
}

// Unicode v. 10 support
function isValidIdentifierPart(code) {
    var bit = code & 31;
    return (convert[(code >>> 5) + 0] >>> bit & 1) !== 0;
}
function isValidIdentifierStart(code) {
    var bit = code & 31;
    return (convert[(code >>> 5) + 34816] >>> bit & 1) !== 0;
}
function mustEscape(code) {
    var bit = code & 31;
    return (convert[(code >>> 5) + 69632] >>> bit & 1) !== 0;
}
var convert = (function (compressed, lookup) {
    var result = new Uint32Array(104448);
    var index = 0;
    var subIndex = 0;
    while (index < 3293) {
        var inst = compressed[index++];
        if (inst < 0) {
            subIndex -= inst;
        }
        else {
            var code = compressed[index++];
            if (inst & 2)
                { code = lookup[code]; }
            if (inst & 1) {
                result.fill(code, subIndex, subIndex += compressed[index++]);
            }
            else {
                result[subIndex++] = code;
            }
        }
    }
    return result;
})([-1, 2, 28, 2, 29, 2, 5, -1, 0, 77595648, 3, 41, 2, 3, 0, 14, 2, 52, 2, 53, 3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 54, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 55, 2, 56, 2, 4, 0, 4294836479, 0, 3221225471, 0, 4294901942, 2, 57, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0, 2684354047, 2, 17, 2, 0, 0, 4294961151, 3, 0, 2, 2, 20, 2, 0, 2, 59, 2, 0, 2, 125, 2, 6, 2, 19, -1, 2, 60, 2, 148, 2, 1, 3, 0, 3, 0, 4294901711, 2, 37, 0, 4089839103, 0, 2961209759, 0, 268697551, 0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2965387679, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 2, 167, 2, 3, 0, 3825204735, 0, 123747807, 0, 65487, 2, 3, 0, 4092591615, 0, 1080049119, 0, 458703, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247020, 2, 64, 0, 4284449919, 0, 851904, 2, 4, 2, 16, 0, 67076095, -1, 2, 65, 0, 1006628014, 0, 4093591391, -1, 0, 50331649, 0, 3265266687, 2, 34, 0, 4294844415, 0, 4278190047, 2, 22, 2, 124, -1, 3, 0, 2, 2, 33, 2, 0, 2, 10, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 66, 2, 0, 2, 67, 2, 68, 2, 69, 2, 0, 2, 70, 2, 0, 0, 3892314111, 0, 261632, 2, 27, 3, 0, 2, 2, 11, 2, 4, 3, 0, 18, 2, 71, 2, 5, 3, 0, 2, 2, 72, 0, 2088959, 2, 31, 2, 8, 0, 909311, 3, 0, 2, 0, 814743551, 2, 39, 0, 67057664, 3, 0, 2, 2, 9, 2, 0, 2, 32, 2, 0, 2, 18, 2, 7, 0, 268374015, 2, 30, 2, 46, 2, 0, 2, 73, 0, 134153215, -1, 2, 6, 2, 0, 2, 7, 0, 2684354559, 0, 67044351, 0, 1073676416, -2, 3, 0, 2, 2, 40, 0, 1046528, 3, 0, 3, 2, 8, 2, 0, 2, 9, 0, 4294960127, 2, 10, 2, 13, -1, 0, 4294377472, 2, 25, 3, 0, 7, 0, 4227858431, 3, 0, 8, 2, 11, 2, 0, 2, 75, 2, 10, 2, 0, 2, 76, 2, 77, 2, 78, -1, 2, 121, 0, 1048577, 2, 79, 2, 12, -1, 2, 12, 0, 131042, 2, 80, 2, 81, 2, 82, 2, 0, 2, 13, -83, 2, 0, 2, 49, 2, 7, 3, 0, 4, 0, 1046559, 2, 0, 2, 14, 2, 0, 0, 2147516671, 2, 23, 3, 83, 2, 2, 0, -16, 2, 84, 0, 524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 2, 0, 2, 15, 2, 74, 2, 86, 3, 0, 2, 2, 43, 2, 16, -1, 2, 17, -16, 3, 0, 205, 2, 18, -2, 3, 0, 655, 2, 19, 3, 0, 36, 2, 47, -1, 2, 17, 2, 10, 3, 0, 8, 2, 87, 2, 117, 2, 0, 0, 3220242431, 3, 0, 3, 2, 20, 2, 21, 2, 88, 3, 0, 2, 2, 89, 2, 90, -1, 2, 21, 2, 0, 2, 26, 2, 0, 2, 8, 3, 0, 2, 0, 67043391, 0, 687865855, 2, 0, 2, 24, 2, 8, 2, 22, 3, 0, 2, 0, 67076097, 2, 7, 2, 0, 2, 23, 0, 67059711, 0, 4236247039, 3, 0, 2, 0, 939524103, 0, 8191999, 2, 94, 2, 95, 2, 15, 2, 92, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 96, 2, 97, 2, 6, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 25, -1, 0, 3774349439, 2, 98, 2, 99, 3, 0, 2, 2, 20, 2, 100, 3, 0, 10, 2, 10, 2, 17, 2, 0, 2, 42, 2, 0, 2, 26, 2, 101, 2, 27, 0, 1638399, 2, 165, 2, 102, 3, 0, 3, 2, 22, 2, 28, 2, 29, 2, 5, 2, 30, 2, 0, 2, 7, 2, 103, -1, 2, 104, 2, 105, 2, 106, -1, 3, 0, 3, 2, 16, -2, 2, 0, 2, 31, -3, 2, 144, -4, 2, 22, 2, 0, 2, 107, 0, 1, 2, 0, 2, 58, 2, 32, 2, 16, 2, 10, 2, 0, 2, 108, -1, 3, 0, 4, 2, 10, 2, 33, 2, 109, 2, 6, 2, 0, 2, 110, 2, 0, 2, 44, -4, 3, 0, 9, 2, 23, 2, 18, 2, 26, -4, 2, 111, 2, 112, 2, 18, 2, 23, 2, 7, -2, 2, 113, 2, 18, 2, 25, -2, 2, 0, 2, 114, -2, 0, 4277137519, 0, 2265972735, -1, 3, 22, 2, -1, 2, 34, 2, 36, 2, 0, 3, 18, 2, 2, 35, 2, 20, -3, 3, 0, 2, 2, 13, -1, 2, 0, 2, 35, 2, 0, 2, 35, -24, 3, 0, 2, 2, 36, 0, 2147549120, 2, 0, 2, 16, 2, 17, 2, 128, 2, 0, 2, 48, 2, 17, 0, 5242879, 3, 0, 2, 0, 402594847, -1, 2, 116, 0, 1090519039, -2, 2, 118, 2, 119, 2, 0, 2, 38, 2, 37, 2, 2, 0, 3766565279, 0, 2039759, -4, 3, 0, 2, 2, 38, -1, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0, 1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 9, 2, 39, -1, 0, 3825205247, 2, 40, -11, 3, 0, 2, 0, 2147484671, -8, 2, 0, 2, 7, 0, 4294901888, 2, 0, 0, 67108815, -1, 2, 0, 2, 45, -8, 2, 50, 2, 41, 0, 67043329, 2, 122, 2, 42, 0, 8388351, -2, 2, 123, 0, 3028287487, 0, 67043583, -21, 3, 0, 28, 2, 25, -3, 3, 0, 3, 2, 43, 3, 0, 6, 2, 44, -85, 3, 0, 33, 2, 43, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 45, 2, 7, 2, 39, -2, 2, 17, 2, 46, 2, 0, 2, 23, 0, 67043343, 2, 126, 2, 27, -27, 3, 0, 2, 0, 4294901791, 2, 7, 2, 187, -2, 0, 3, 3, 0, 191, 2, 47, 3, 0, 23, 2, 35, -296, 3, 0, 8, 2, 7, -2, 2, 17, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 127, 0, 1677656575, -166, 0, 4161266656, 0, 4071, 0, 15360, -4, 0, 28, -13, 3, 0, 2, 2, 48, 2, 0, 2, 129, 2, 130, 2, 51, 2, 0, 2, 131, 2, 132, 2, 133, 3, 0, 10, 2, 134, 2, 135, 2, 15, 3, 48, 2, 3, 49, 2, 3, 50, 2, 0, 4294954999, 2, 0, -16, 2, 0, 2, 85, 2, 0, 0, 2105343, 0, 4160749584, 2, 194, -42, 0, 4194303871, 0, 2011, -62, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 38, -37, 2, 51, 2, 138, 2, 139, 2, 140, 2, 141, 2, 142, -138, 3, 0, 1334, 2, 23, -1, 3, 0, 129, 2, 31, 3, 0, 6, 2, 10, 3, 0, 180, 2, 143, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 10, -22583, 3, 0, 7, 2, 27, -6130, 3, 5, 2, -1, 0, 69207040, 3, 41, 2, 3, 0, 14, 2, 52, 2, 53, -3, 0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 54, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 55, 2, 56, 2, 4, 2, 26, -1, 2, 17, 2, 57, -1, 2, 0, 2, 19, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 27, 2, 58, 3, 0, 2, 0, 131135, 2, 91, 0, 70256639, 2, 59, 0, 272, 2, 45, 2, 19, -1, 2, 60, -2, 2, 93, 0, 603979775, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 61, 2, 62, 0, 33554435, 2, 120, 2, 61, 2, 145, 0, 131075, 0, 3594373096, 0, 67094296, 2, 62, -1, 2, 63, 0, 603979263, 2, 153, 0, 3, 0, 4294828001, 0, 602930687, 2, 175, 0, 393219, 2, 63, 0, 671088639, 0, 2154840064, 0, 4227858435, 0, 4236247008, 2, 64, 2, 36, -1, 2, 4, 0, 917503, 2, 36, -1, 2, 65, 0, 537783470, 0, 4026531935, -1, 0, 1, -1, 2, 34, 2, 47, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2, 14, 2, 15, 3, 0, 10, 2, 66, 2, 0, 2, 67, 2, 68, 2, 69, 2, 0, 2, 70, 2, 0, 2, 16, -1, 2, 27, 3, 0, 2, 2, 11, 2, 4, 3, 0, 18, 2, 71, 2, 5, 3, 0, 2, 2, 72, 0, 253951, 3, 20, 2, 0, 122879, 2, 0, 2, 8, 0, 276824064, -2, 3, 0, 2, 2, 9, 2, 0, 0, 4294903295, 2, 0, 2, 18, 2, 7, -1, 2, 17, 2, 46, 2, 0, 2, 73, 2, 39, -1, 2, 23, 2, 0, 2, 31, -2, 0, 128, -2, 2, 74, 2, 8, 0, 4064, -1, 2, 115, 0, 4227907585, 2, 0, 2, 191, 2, 0, 2, 44, 0, 4227915776, 2, 10, 2, 13, -2, 0, 6544896, 3, 0, 6, -2, 3, 0, 8, 2, 11, 2, 0, 2, 75, 2, 10, 2, 0, 2, 76, 2, 77, 2, 78, -3, 2, 79, 2, 12, -3, 2, 80, 2, 81, 2, 82, 2, 0, 2, 13, -83, 2, 0, 2, 49, 2, 7, 3, 0, 4, 0, 817183, 2, 0, 2, 14, 2, 0, 0, 33023, 2, 23, 3, 83, 2, -17, 2, 84, 0, 524157950, 2, 4, 2, 0, 2, 85, 2, 4, 2, 0, 2, 15, 2, 74, 2, 86, 3, 0, 2, 2, 43, 2, 16, -1, 2, 17, -16, 3, 0, 205, 2, 18, -2, 3, 0, 655, 2, 19, 3, 0, 36, 2, 47, -1, 2, 17, 2, 10, 3, 0, 8, 2, 87, 0, 3072, 2, 0, 0, 2147516415, 2, 10, 3, 0, 2, 2, 27, 2, 21, 2, 88, 3, 0, 2, 2, 89, 2, 90, -1, 2, 21, 0, 4294965179, 0, 7, 2, 0, 2, 8, 2, 88, 2, 8, -1, 0, 687603712, 2, 91, 2, 92, 2, 36, 2, 22, 2, 93, 2, 35, 2, 159, 0, 2080440287, 2, 0, 2, 13, 2, 136, 0, 3296722943, 2, 0, 0, 1046675455, 0, 939524101, 0, 1837055, 2, 94, 2, 95, 2, 15, 2, 92, 3, 0, 3, 0, 7, 3, 0, 349, 2, 96, 2, 97, 2, 6, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 25, -1, 0, 2700607615, 2, 98, 2, 99, 3, 0, 2, 2, 20, 2, 100, 3, 0, 10, 2, 10, 2, 17, 2, 0, 2, 42, 2, 0, 2, 26, 2, 101, -3, 2, 102, 3, 0, 3, 2, 22, -1, 3, 5, 2, 2, 30, 2, 0, 2, 7, 2, 103, -1, 2, 104, 2, 105, 2, 106, -1, 3, 0, 3, 2, 16, -2, 2, 0, 2, 31, -8, 2, 22, 2, 0, 2, 107, -1, 2, 0, 2, 58, 2, 32, 2, 18, 2, 10, 2, 0, 2, 108, -1, 3, 0, 4, 2, 10, 2, 17, 2, 109, 2, 6, 2, 0, 2, 110, 2, 0, 2, 44, -4, 3, 0, 9, 2, 23, 2, 18, 2, 26, -4, 2, 111, 2, 112, 2, 18, 2, 23, 2, 7, -2, 2, 113, 2, 18, 2, 25, -2, 2, 0, 2, 114, -2, 0, 4277075969, 2, 8, -1, 3, 22, 2, -1, 2, 34, 2, 137, 2, 0, 3, 18, 2, 2, 35, 2, 20, -3, 3, 0, 2, 2, 13, -1, 2, 0, 2, 35, 2, 0, 2, 35, -24, 2, 115, 2, 9, -2, 2, 115, 2, 27, 2, 17, 2, 13, 2, 115, 2, 36, 2, 17, 0, 4718591, 2, 115, 2, 35, 0, 335544350, -1, 2, 116, 2, 117, -2, 2, 118, 2, 119, 2, 7, -1, 2, 120, 2, 61, 0, 3758161920, 0, 3, -4, 2, 0, 2, 31, 2, 170, -1, 2, 0, 2, 27, 0, 176, -5, 2, 0, 2, 43, 2, 177, -1, 2, 0, 2, 27, 2, 189, -1, 2, 0, 2, 19, -2, 2, 25, -12, 3, 0, 2, 2, 121, -8, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 975, -1, 2, 0, 2, 45, -8, 2, 50, 2, 43, 0, 1, 2, 122, 2, 27, -3, 2, 123, 2, 107, 2, 124, -21, 3, 0, 28, 2, 25, -3, 3, 0, 3, 2, 43, 3, 0, 6, 2, 44, -85, 3, 0, 33, 2, 43, -126, 3, 0, 18, 2, 36, -269, 3, 0, 17, 2, 45, 2, 7, -3, 2, 17, 2, 125, 2, 0, 2, 27, 2, 44, 2, 126, 2, 27, -27, 3, 0, 2, 0, 65567, -1, 2, 100, -2, 0, 3, 3, 0, 191, 2, 47, 3, 0, 23, 2, 35, -296, 3, 0, 8, 2, 7, -2, 2, 17, 3, 0, 11, 2, 6, -72, 3, 0, 3, 2, 127, 2, 128, -187, 3, 0, 2, 2, 48, 2, 0, 2, 129, 2, 130, 2, 51, 2, 0, 2, 131, 2, 132, 2, 133, 3, 0, 10, 2, 134, 2, 135, 2, 15, 3, 48, 2, 3, 49, 2, 3, 50, 2, 2, 136, -129, 3, 0, 6, 2, 137, -1, 3, 0, 2, 2, 44, -37, 2, 51, 2, 138, 2, 139, 2, 140, 2, 141, 2, 142, -138, 3, 0, 1334, 2, 23, -1, 3, 0, 129, 2, 31, 3, 0, 6, 2, 10, 3, 0, 180, 2, 143, 3, 0, 233, 0, 1, -96, 3, 0, 16, 2, 10, -28719, 2, 0, 0, 1, -1, 2, 121, 2, 0, 0, 8193, -21, 0, 50331648, 0, 10255, 0, 4, -11, 2, 62, 2, 163, 0, 1, 0, 71936, -1, 2, 154, 0, 4292933632, 0, 805306431, -5, 2, 144, -1, 2, 172, -1, 0, 6144, -2, 2, 122, -1, 2, 164, -1, 2, 150, 2, 145, 2, 158, 2, 0, 0, 3223322624, 2, 8, 0, 4, -4, 2, 183, 0, 205128192, 0, 1333757536, 0, 3221225520, 0, 423953, 0, 747766272, 0, 2717763192, 0, 4290773055, 0, 278545, 2, 146, 0, 4294886464, 0, 33292336, 0, 417809, 2, 146, 0, 1329579616, 0, 4278190128, 0, 700594195, 0, 1006647527, 0, 4286497336, 0, 4160749631, 2, 147, 0, 469762560, 0, 4171219488, 0, 16711728, 2, 147, 0, 202375680, 0, 3214918176, 0, 4294508592, 2, 147, -1, 0, 983584, 0, 48, 0, 58720275, 0, 3489923072, 0, 10517376, 0, 4293066815, 0, 1, 0, 2013265920, 2, 171, 2, 0, 0, 17816169, 0, 3288339281, 0, 201375904, 2, 0, -2, 0, 256, 0, 122880, 0, 16777216, 2, 144, 0, 4160757760, 2, 0, -6, 2, 160, -11, 0, 3263218176, -1, 0, 49664, 0, 2160197632, 0, 8388802, -1, 0, 12713984, -1, 0, 402653184, 2, 152, 2, 155, -2, 2, 156, -20, 0, 3758096385, -2, 2, 185, 0, 4292878336, 2, 21, 2, 148, 0, 4294057984, -2, 2, 157, 2, 149, 2, 168, -2, 2, 166, -1, 2, 174, -1, 2, 162, 2, 121, 0, 4026593280, 0, 14, 0, 4292919296, -1, 2, 151, 0, 939588608, -1, 0, 805306368, -1, 2, 121, 0, 1610612736, 2, 149, 2, 150, 3, 0, 2, -2, 2, 151, 2, 152, -3, 0, 267386880, -1, 2, 153, 0, 7168, -1, 2, 180, 2, 0, 2, 154, 2, 155, -7, 2, 161, -8, 2, 156, -1, 0, 1426112704, 2, 157, -1, 2, 181, 0, 271581216, 0, 2149777408, 2, 27, 2, 154, 2, 121, 0, 851967, 0, 3758129152, -1, 2, 27, 2, 173, -4, 2, 151, -20, 2, 188, 2, 158, -56, 0, 3145728, 2, 179, 2, 184, 0, 4294443520, 2, 73, -1, 2, 159, 2, 121, -4, 0, 32505856, -1, 2, 160, -1, 0, 2147385088, 2, 21, 1, 2155905152, 2, -3, 2, 91, 2, 0, 2, 161, -2, 2, 148, -6, 2, 162, 0, 4026597375, 0, 1, -1, 0, 1, -1, 2, 163, -3, 2, 137, 2, 190, -2, 2, 159, 2, 164, -1, 2, 169, 2, 121, -6, 2, 121, -213, 2, 162, -657, 2, 158, -36, 2, 165, -1, 0, 65408, -10, 2, 193, -5, 2, 166, -5, 0, 4278222848, 2, 0, 2, 23, -1, 0, 4227919872, -1, 2, 166, -2, 0, 4227874752, 2, 157, -2, 0, 2146435072, 2, 152, -2, 0, 1006649344, 2, 121, -1, 2, 21, 0, 201375744, -3, 0, 134217720, 2, 21, 0, 4286677377, 0, 32896, -1, 2, 167, -3, 2, 168, -349, 2, 169, 2, 170, 2, 171, 3, 0, 264, -11, 2, 172, -2, 2, 155, 2, 0, 0, 520617856, 0, 2692743168, 0, 36, -3, 0, 524284, -11, 2, 27, -1, 2, 178, -1, 2, 176, 0, 3221291007, 2, 155, -1, 0, 524288, 0, 2158720, -3, 2, 152, 0, 1, -4, 2, 121, 0, 3808625411, 0, 3489628288, 0, 4096, 0, 1207959680, 0, 3221274624, 2, 0, -3, 2, 164, 0, 120, 0, 7340032, -2, 0, 4026564608, 2, 4, 2, 27, 2, 157, 3, 0, 4, 2, 152, -1, 2, 173, 2, 171, -1, 0, 8176, 2, 174, 2, 164, 2, 175, -1, 0, 4290773232, 2, 0, -4, 2, 157, 2, 182, 0, 15728640, 2, 171, -1, 2, 154, -1, 0, 4294934512, 3, 0, 4, -9, 2, 21, 2, 162, 2, 176, 3, 0, 4, 0, 704, 0, 1849688064, 0, 4194304, -1, 2, 121, 0, 4294901887, 2, 0, 0, 130547712, 0, 1879048192, 0, 2080374784, 3, 0, 2, -1, 2, 177, 2, 178, -1, 0, 17829776, 0, 2028994560, 0, 4261478144, -2, 2, 0, -1, 0, 4286580608, -1, 0, 29360128, 2, 179, 0, 16252928, 0, 3791388672, 2, 119, 3, 0, 2, -2, 2, 180, 2, 0, -1, 2, 100, -1, 0, 66584576, 3, 0, 11, 2, 121, 3, 0, 12, -2, 0, 245760, 0, 2147418112, -1, 2, 144, 2, 195, 0, 4227923456, -1, 2, 181, 2, 169, 2, 21, -2, 2, 172, 0, 4292870145, 0, 262144, 2, 121, 3, 0, 2, 0, 1073758848, 2, 182, -1, 0, 4227921920, 2, 183, 2, 146, 0, 528402016, 0, 4292927536, 3, 0, 4, -2, 0, 3556769792, 2, 0, -2, 2, 186, 3, 0, 5, -1, 2, 179, 2, 157, 2, 0, -2, 0, 4227923936, 2, 58, -1, 2, 166, 2, 91, 2, 0, 2, 184, 2, 151, 3, 0, 11, -2, 0, 2146959360, 3, 0, 8, -2, 2, 154, -1, 0, 536870960, 2, 115, -1, 2, 185, 3, 0, 8, 0, 512, 0, 8388608, 2, 167, 2, 165, 2, 178, 0, 4286578944, 3, 0, 2, 0, 1152, 0, 1266679808, 2, 186, 3, 0, 21, -28, 2, 155, 3, 0, 3, -3, 0, 4292902912, -6, 2, 93, 3, 0, 85, -33, 2, 187, 3, 0, 126, -18, 2, 188, 3, 0, 269, -17, 2, 185, 2, 121, 0, 4294917120, 3, 0, 2, 2, 27, 0, 4290822144, -2, 0, 67174336, 0, 520093700, 2, 17, 3, 0, 27, -2, 0, 65504, 2, 121, 2, 43, 3, 0, 2, 2, 88, -191, 2, 58, -23, 2, 100, 3, 0, 296, -8, 2, 121, 3, 0, 2, 2, 27, -11, 2, 171, 3, 0, 72, -3, 0, 3758159872, 0, 201391616, 3, 0, 155, -7, 2, 162, -1, 0, 384, -1, 0, 133693440, -3, 2, 180, -2, 2, 30, 3, 0, 5, -2, 2, 21, 2, 122, 3, 0, 4, -2, 2, 181, -1, 2, 144, 0, 335552923, 2, 189, -1, 0, 538974272, 0, 2214592512, 0, 132000, -10, 0, 192, -8, 0, 12288, -21, 0, 134213632, 0, 4294901761, 3, 0, 42, 0, 100663424, 0, 4294965284, 3, 0, 62, -6, 0, 4286578784, 2, 0, -2, 0, 1006696448, 3, 0, 37, 2, 189, 0, 4110942569, 0, 1432950139, 0, 2701658217, 0, 4026532864, 0, 4026532881, 2, 0, 2, 42, 3, 0, 8, -1, 2, 151, -2, 2, 148, 2, 190, 0, 65537, 2, 162, 2, 165, 2, 159, -1, 2, 151, -1, 2, 58, 2, 0, 2, 191, 0, 65528, 2, 171, 0, 4294770176, 2, 30, 3, 0, 4, -30, 2, 192, 0, 4261470208, -3, 2, 148, -2, 2, 192, 2, 0, 2, 151, -1, 2, 186, -1, 2, 154, 0, 4294950912, 3, 0, 2, 2, 151, 2, 121, 2, 165, 2, 193, 2, 166, 2, 0, 2, 194, 2, 188, 3, 0, 48, -1334, 2, 21, 2, 0, -129, 2, 192, -6, 2, 157, -180, 2, 195, -233, 2, 4, 3, 0, 96, -16, 2, 157, 3, 0, 22583, -7, 2, 17, 3, 0, 6128], [4294967295, 4294967291, 4092460543, 4294828015, 4294967294, 134217726, 268435455, 2147483647, 1048575, 16777215, 1073741823, 1061158911, 536805376, 511, 4294910143, 4160749567, 134217727, 4294901760, 4194303, 2047, 262143, 4286578688, 536870911, 8388607, 4294918143, 67108863, 255, 65535, 67043328, 2281701374, 4294967232, 2097151, 4294903807, 4294902783, 4294967039, 524287, 127, 4294549487, 67045375, 1023, 67047423, 4286578687, 4294770687, 32767, 15, 33554431, 2047999, 8191, 4292870143, 4294934527, 4294966783, 4294967279, 262083, 20511, 4290772991, 4294901759, 41943039, 460799, 4294959104, 71303167, 1071644671, 602799615, 65536, 4294828000, 805044223, 4277151126, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095, 4294905855, 4294967264, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294868991, 4294909951, 4294967292, 4294965759, 16744447, 4294966272, 4294901823, 4294967280, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008, 268369920, 4292804608, 486341884, 4294963199, 3087007615, 1073692671, 131071, 4128527, 4279238655, 4294902015, 4294966591, 2445279231, 3670015, 3238002687, 4294967288, 4294705151, 4095, 3221208447, 4294902271, 4294549472, 2147483648, 4294705152, 4294966143, 64, 16383, 3774873592, 536807423, 67043839, 3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4087, 31, 184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 536870912, 2952790016, 202506752, 139280, 4293918720, 4227922944, 2147532800, 61440, 3758096384, 117440512, 65280, 4227858432, 3233808384, 3221225472, 4294965248, 32768, 57152, 67108864, 4290772992, 25165824, 4160749568, 57344, 4278190080, 65472, 4227907584, 65520, 1920, 4026531840, 49152, 4294836224, 63488, 1073741824, 4294967040, 251658240, 196608, 12582912, 4294966784, 2097152, 64512, 417808, 469762048, 4261412864, 4227923712, 4294934528, 4294967168, 16, 98304, 63, 4292870144, 4294963200, 65534, 65532]);

var isInOrOfKeyword = function (t) { return t === 669489 /* InKeyword */ || t === 69747; } /* OfKeyword */;
var isPrologueDirective = function (node) { return node.type === 'ExpressionStatement' && node.expression.type === 'Literal'; };
var hasBit = function (mask, flags) { return (mask & flags) === flags; };
var fromCodePoint = function (code) {
    return code <= 0xFFFF ?
        String.fromCharCode(code) :
        String.fromCharCode(((code - 65536 /* NonBMPMin */) >> 10) +
            55296 /* LeadSurrogateMin */, ((code - 65536 /* NonBMPMin */) & (1024 - 1)) + 56320 /* TrailSurrogateMin */);
};
function toHex(code) {
    if (code <= 57 /* Nine */)
        { return code - 48 /* Zero */; }
    if (code < 65 /* UpperA */)
        { return -1; }
    if (code <= 70 /* UpperF */)
        { return code - 65 /* UpperA */ + 10; }
    if (code < 97 /* LowerA */)
        { return -1; }
    if (code <= 102 /* LowerF */)
        { return code - 97 /* LowerA */ + 10; }
    return -1;
}
function isValidSimpleAssignmentTarget(expr) {
    if (expr.type === 'Identifier' || expr.type === 'MemberExpression')
        { return true; }
    return false;
}
var map = (function () {
    return typeof Map === 'function' ? {
        create: function () { return new Map(); },
        get: function (m, k) { return m.get(k); },
        set: function (m, k, v) { return m.set(k, v); },
    } : {
        create: function () { return Object.create(null); },
        get: function (m, k) { return m[k]; },
        set: function (m, k, v) { return m[k] = v; },
    };
})();
function isValidDestructuringAssignmentTarget(expr) {
    switch (expr.type) {
        case 'Identifier':
        case 'ArrayExpression':
        case 'ArrayPattern':
        case 'ObjectExpression':
        case 'RestElement':
        case 'ObjectPattern':
        case 'MemberExpression':
        case 'ClassExpression':
        case 'CallExpression':
        case 'TemplateLiteral':
        case 'AssignmentExpression':
        case 'NewExpression':
            return true;
        default:
            return false;
    }
}
function invalidCharacterMessage(cp) {
    if (!mustEscape(cp))
        { return fromCodePoint(cp); }
    if (cp < 0x10)
        { return ("\\x0" + (cp.toString(16))); }
    if (cp < 0x100)
        { return ("\\x" + (cp.toString(16))); }
    if (cp < 0x1000)
        { return ("\\u0" + (cp.toString(16))); }
    if (cp < 0x10000)
        { return ("\\u" + (cp.toString(16))); }
    return ("\\u{" + (cp.toString(16)) + "}");
}
// Fully qualified element name, e.g. <svg:path> returns "svg:path"
function isQualifiedJSXName(elementName) {
    switch (elementName.type) {
        case 'JSXIdentifier':
            return elementName.name;
        case 'JSXNamespacedName':
            return elementName.namespace + ':' + elementName.name;
        case 'JSXMemberExpression':
            return (isQualifiedJSXName(elementName.object) + '.' +
                isQualifiedJSXName(elementName.property));
        /* istanbul ignore next */
        default:
    }
}
var isIdentifierPart = function (code) { return isValidIdentifierPart(code) ||
    code === 92 /* Backslash */ ||
    code === 36 /* Dollar */ ||
    code === 95 /* Underscore */ ||
    (code >= 48 /* Zero */ && code <= 57 /* Nine */); }; // 0..9;
function getCommentType(state) {
    if (state & 32 /* SingleLine */)
        { return 'SingleLine'; }
    if (state & 64 /* HTMLOpen */)
        { return 'HTMLOpen'; }
    if (state & 128 /* HTMLClose */)
        { return 'HTMLClose'; }
    if (state & 256 /* SheBang */)
        { return 'SheBang'; }
    return 'MultiLine';
}
function isPropertyWithPrivateFieldKey(context, expr) {
    if (!expr.property)
        { return false; }
    return expr.property.type === 'PrivateName';
}

function isDecimalDigit(ch) {
    return ch >= 48 /* Zero */ && ch <= 57 /* Nine */;
}
var Parser = function Parser(source, sourceFile) {
    this.source = source;
    this.token = 0 /* EndOfSource */;
    this.flags = 0 /* None */;
    this.index = 0;
    this.line = 1;
    this.column = 0;
    this.startIndex = 0;
    this.startLine = 1;
    this.startColumn = 0;
    this.lastColumn = 0;
    this.lastIndex = 0;
    this.lastLine = 0;
    this.lastColumn = 0;
    this.tokenRaw = '';
    this.tokenValue = undefined;
    this.tokenRegExp = undefined;
    this.labelSet = undefined;
    this.errorLocation = undefined;
    this.lastChar = 0;
    this.sourceFile = sourceFile;
    this.comments = [];
    this.errors = [];
};
// https://tc39.github.io/ecma262/#sec-scripts
// https://tc39.github.io/ecma262/#sec-modules
Parser.prototype.parseProgram = function parseProgram (context, options, delegate) {
    if (options != null) {
        if (options.next)
            { context |= 1 /* OptionsNext */; }
        if (options.ranges)
            { context |= 2 /* OptionsRanges */; }
        if (options.raw)
            { context |= 8 /* OptionsRaw */; }
        if (options.loc)
            { context |= 4 /* OptionsLoc */; }
        if (options.jsx)
            { context |= 64 /* OptionsJSX */; }
        if (options.ranges)
            { context |= 2 /* OptionsRanges */; }
        if (options.tolerate)
            { context |= 32 /* OptionsTolerate */; }
        if (options.impliedStrict)
            { context |= 512 /* Strict */; }
        if (options.comments)
            { context |= 16 /* OptionsComments */; }
        if (context & 128 /* OptionsDelegate */)
            { this.delegate = delegate; }
    }
    var node = {
        type: 'Program',
        sourceType: context & 1024 /* Module */ ? 'module' : 'script',
        body: context & 1024 /* Module */ ?
            this.parseModuleItemList(context) : this.parseStatementList(context)
    };
    if (context & 2 /* OptionsRanges */) {
        node.start = 0;
        node.end = this.source.length;
    }
    if (context & 4 /* OptionsLoc */) {
        node.loc = {
            start: {
                line: 1,
                column: 0,
            },
            end: {
                line: this.line,
                column: this.column
            }
        };
        if (this.sourceFile) {
            node.loc.source = this.sourceFile;
        }
    }
    if (context & 32 /* OptionsTolerate */) {
        node.errors = this.errors;
    }
    if (context & 16 /* OptionsComments */) {
        node.comments = this.comments;
    }
    return node;
};
Parser.prototype.parseStatementList = function parseStatementList (context) {
        var this$1 = this;

    this.nextToken(context);
    var statements = [];
    // "use strict" must be the exact literal without escape sequences or line continuation.
    while (this.token === 131075 /* StringLiteral */) {
        var item = this$1.parseDirective(context);
        statements.push(item);
        if (!isPrologueDirective(item))
            { break; }
        if (this$1.flags & 1024 /* StrictDirective */)
            { context |= 512 /* Strict */; }
        break;
    }
    while (this.token !== 0 /* EndOfSource */) {
        statements.push(this$1.parseStatementListItem(context));
    }
    return statements;
};
Parser.prototype.parseModuleItemList = function parseModuleItemList (context) {
        var this$1 = this;

    // Prime the scanner
    this.nextToken(context);
    var statements = [];
    while (this.token === 131075 /* StringLiteral */) {
        statements.push(this$1.parseDirective(context));
    }
    while (this.token !== 0 /* EndOfSource */) {
        statements.push(this$1.parseModuleItem(context | 256 /* AllowIn */));
    }
    return statements;
};
Parser.prototype.hasNext = function hasNext () {
    return this.index < this.source.length;
};
Parser.prototype.advance = function advance () {
    this.index++;
    this.column++;
};
Parser.prototype.consumeUnicode = function consumeUnicode (ch) {
    this.advance();
    if (ch > 0xffff)
        { this.index++; }
};
Parser.prototype.nextChar = function nextChar () {
    return this.source.charCodeAt(this.index);
};
Parser.prototype.storeRaw = function storeRaw (start) {
    this.tokenRaw = this.source.slice(start, this.index);
};
Parser.prototype.readNext = function readNext (prev, message /* Unexpected */) {
        if ( message === void 0 ) message = 0;

    this.consumeUnicode(prev);
    if (!this.hasNext())
        { return this.report(message); }
    return this.nextUnicodeChar();
};
Parser.prototype.nextUnicodeChar = function nextUnicodeChar () {
    var index = this.index;
    var hi = this.source.charCodeAt(index);
    if (hi < 55296 /* LeadSurrogateMin */ || hi > 56319 /* LeadSurrogateMax */)
        { return hi; }
    var lo = this.source.charCodeAt(index + 1);
    if (lo < 56320 /* TrailSurrogateMin */ || lo > 57343 /* TrailSurrogateMax */)
        { return hi; }
    return 65536 /* NonBMPMin */ + ((hi & 0x3FF) << 10) | lo & 0x3FF;
};
Parser.prototype.consumeOpt = function consumeOpt (code) {
    if (this.source.charCodeAt(this.index) !== code)
        { return false; }
    this.index++;
    this.column++;
    return true;
};
Parser.prototype.consumeLineFeed = function consumeLineFeed (state) {
    this.flags |= 1 /* LineTerminator */;
    this.index++;
    if ((state & 4 /* LastIsCR */) === 0) {
        this.column = 0;
        this.line++;
    }
};
Parser.prototype.advanceNewline = function advanceNewline () {
    this.flags |= 1 /* LineTerminator */;
    this.index++;
    this.column = 0;
    this.line++;
};
Parser.prototype.scan = function scan (context) {
        var this$1 = this;

    this.flags &= ~(1 /* LineTerminator */ | 512 /* HasEscapedKeyword */);
    var state = this.index === 0 ? 8 /* LineStart */ : 0 /* None */;
    while (this.hasNext()) {
        if (this$1.index > 0) {
            this$1.startIndex = this$1.index;
            this$1.startColumn = this$1.column;
            this$1.startLine = this$1.line;
        }
        var first = this$1.nextChar();
        if (first >= 128)
            { first = this$1.nextUnicodeChar(); }
        switch (first) {
            case 13 /* CarriageReturn */:
                state |= 1 /* NewLine */ | 4 /* LastIsCR */;
                this$1.advanceNewline();
                continue;
            case 10 /* LineFeed */:
                this$1.consumeLineFeed(state);
                state = state & ~4 /* LastIsCR */ | 1 /* NewLine */;
                continue;
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                state = state & ~4 /* LastIsCR */ | 1 /* NewLine */;
                this$1.advanceNewline();
                continue;
            case 65519 /* ByteOrderMark */:
            case 9 /* Tab */:
            case 11 /* VerticalTab */:
            case 12 /* FormFeed */:
            case 32 /* Space */:
            case 160 /* NonBreakingSpace */:
            case 5760 /* Ogham */:
            case 8192 /* EnQuad */:
            case 8193 /* EmQuad */:
            case 8194 /* EnSpace */:
            case 8195 /* EmSpace */:
            case 8196 /* ThreePerEmSpace */:
            case 8197 /* FourPerEmSpace */:
            case 8198 /* SixPerEmSpace */:
            case 8199 /* FigureSpace */:
            case 8200 /* PunctuationSpace */:
            case 8201 /* ThinSpace */:
            case 8202 /* HairSpace */:
            case 8239 /* NarrowNoBreakSpace */:
            case 8287 /* MathematicalSpace */:
            case 12288 /* IdeographicSpace */:
            case 65279 /* ZeroWidthNoBreakSpace */:
            case 8204 /* ZeroWidthJoiner */:
            case 8205 /* ZeroWidthNonJoiner */:
                state |= 2 /* SameLine */;
                this$1.advance();
                continue;
            case 47 /* Slash */:
                {
                    state |= 2 /* SameLine */;
                    this$1.advance();
                    switch (this$1.nextChar()) {
                        // Look for a single-line comment.
                        case 47 /* Slash */:
                            {
                                this$1.advance();
                                state = this$1.skipSingleLineComment(context, state | 32 /* SingleLine */);
                                continue;
                            }
                        // Look for a multi-line comment.
                        case 42 /* Asterisk */:
                            {
                                this$1.advance();
                                state = this$1.skipMultiLineComment(context, state);
                                continue;
                            }
                        case 61 /* EqualSign */:
                            {
                                this$1.advance();
                                return 393253 /* DivideAssign */;
                            }
                        default:
                            return 657973 /* Divide */;
                    }
                }
            // `<`, `<=`, `<<`, `<<=`, `</`,  <!--
            case 60 /* LessThan */:
                {
                    this$1.advance(); // skip `<`
                    if (!(context & 1024 /* Module */) &&
                        this$1.nextChar() === 33 /* Exclamation */ &&
                        this$1.source.charCodeAt(this$1.index + 1) === 45 /* Hyphen */ &&
                        this$1.source.charCodeAt(this$1.index + 2) === 45 /* Hyphen */) {
                        this$1.index += 3;
                        this$1.column += 3;
                        state = this$1.skipSingleLineComment(context, state | 64 /* HTMLOpen */);
                        continue;
                    }
                    else {
                        switch (this$1.nextChar()) {
                            case 60 /* LessThan */:
                                this$1.advance();
                                return this$1.consumeOpt(61 /* EqualSign */) ?
                                    262174 /* ShiftLeftAssign */ :
                                    657473 /* ShiftLeft */;
                            case 61 /* EqualSign */:
                                this$1.advance();
                                return 657213 /* LessThanOrEqual */;
                            case 47 /* Slash */:
                                {
                                    if (!(context & 64 /* OptionsJSX */))
                                        { break; }
                                    var index = this$1.index + 1;
                                    if (index < this$1.source.length) {
                                        var next = this$1.source.charCodeAt(index);
                                        if (next === 42 /* Asterisk */ || next === 47 /* Slash */)
                                            { break; }
                                    }
                                    this$1.advance();
                                    return 25 /* JSXClose */;
                                }
                            default: // ignore
                        }
                    }
                    return 657215 /* LessThan */;
                }
            case 45 /* Hyphen */:
                {
                    this$1.advance(); // skip `-`
                    var next$1 = this$1.nextChar();
                    switch (next$1) {
                        case 45 /* Hyphen */:
                            {
                                this$1.advance();
                                if (state & (8 /* LineStart */ | 1 /* NewLine */) &&
                                    this$1.nextChar() === 62 /* GreaterThan */) {
                                    if (!(context & 1024 /* Module */)) {
                                        this$1.advance();
                                        state = this$1.skipSingleLineComment(context, state | 128 /* HTMLClose */);
                                    }
                                    continue;
                                }
                                return 2228252 /* Decrement */;
                            }
                        case 61 /* EqualSign */:
                            {
                                this$1.advance();
                                return 262179 /* SubtractAssign */;
                            }
                        default:
                            return 1706288 /* Subtract */;
                    }
                }
            // `!`, `!=`, `!==`
            case 33 /* Exclamation */:
                this$1.advance();
                if (!this$1.consumeOpt(61 /* EqualSign */))
                    { return 1179693 /* Negate */; }
                if (!this$1.consumeOpt(61 /* EqualSign */))
                    { return 656956 /* LooseNotEqual */; }
                return 656954 /* StrictNotEqual */;
            // `'string'`, `"string"`
            case 39 /* SingleQuote */:
            case 34 /* DoubleQuote */:
                return this$1.scanString(context, first);
            // `%`, `%=`
            case 37 /* Percent */:
                this$1.advance();
                if (!this$1.consumeOpt(61 /* EqualSign */))
                    { return 657972 /* Modulo */; }
                return 262182 /* ModuloAssign */;
            // `&`, `&&`, `&=`
            case 38 /* Ampersand */:
                {
                    this$1.advance();
                    var next$2 = this$1.nextChar();
                    if (next$2 === 38 /* Ampersand */) {
                        this$1.advance();
                        return 4850231 /* LogicalAnd */;
                    }
                    if (next$2 === 61 /* EqualSign */) {
                        this$1.advance();
                        return 262185 /* BitwiseAndAssign */;
                    }
                    return 656708 /* BitwiseAnd */;
                }
            // `*`, `**`, `*=`, `**=`
            case 42 /* Asterisk */:
                {
                    this$1.advance();
                    var next$3 = this$1.nextChar();
                    if (next$3 === 61 /* EqualSign */) {
                        this$1.advance();
                        return 262180 /* MultiplyAssign */;
                    }
                    if (next$3 !== 42 /* Asterisk */)
                        { return 67766835 /* Multiply */; }
                    this$1.advance();
                    if (!this$1.consumeOpt(61 /* EqualSign */))
                        { return 658230 /* Exponentiate */; }
                    return 262177 /* ExponentiateAssign */;
                }
            // `+`, `++`, `+=`
            case 43 /* Plus */:
                {
                    this$1.advance();
                    var next$4 = this$1.nextChar();
                    if (next$4 === 43 /* Plus */) {
                        this$1.advance();
                        return 2228251 /* Increment */;
                    }
                    if (next$4 === 61 /* EqualSign */) {
                        this$1.advance();
                        return 262178 /* AddAssign */;
                    }
                    return 1706287 /* Add */;
                }
            // `#`
            case 35 /* Hash */:
                {
                    var index$1 = this$1.index + 1;
                    var next$5 = this$1.source.charCodeAt(index$1);
                    if (state & 8 /* LineStart */ &&
                        next$5 === 33 /* Exclamation */) {
                        index$1++;
                        if (index$1 < this$1.source.length) {
                            this$1.skipSingleLineComment(context, state | 256 /* SheBang */);
                            continue;
                        }
                    }
                    return this$1.scanPrivateName(context, first);
                }
            // `.`, `...`, `.123` (numeric literal)
            case 46 /* Period */:
                {
                    var index$2 = this$1.index + 1;
                    var next$6 = this$1.source.charCodeAt(index$2);
                    if (next$6 >= 48 /* Zero */ && next$6 <= 57 /* Nine */) {
                        this$1.scanNumeric(context, 64 /* Float */, first);
                        return 131074 /* NumericLiteral */;
                    }
                    if (next$6 === 46 /* Period */) {
                        index$2++;
                        if (index$2 < this$1.source.length) {
                            var nextChar = this$1.source.charCodeAt(index$2);
                            if (this$1.source.charCodeAt(index$2) === 46 /* Period */) {
                                this$1.index = index$2 + 1;
                                this$1.column += 3;
                                return 14 /* Ellipsis */;
                            }
                        }
                    }
                    this$1.advance();
                    return 13 /* Period */;
                }
            // `0`...`9`
            case 48 /* Zero */:
            case 49 /* One */:
            case 50 /* Two */:
            case 51 /* Three */:
            case 52 /* Four */:
            case 53 /* Five */:
            case 54 /* Six */:
            case 55 /* Seven */:
            case 56 /* Eight */:
            case 57 /* Nine */:
                return this$1.scanNumeric(context, 1 /* Decimal */, first);
            // `=`, `==`, `===`, `=>`
            case 61 /* EqualSign */:
                {
                    this$1.advance();
                    var next$7 = this$1.nextChar();
                    if (next$7 === 61 /* EqualSign */) {
                        this$1.advance();
                        return this$1.consumeOpt(61 /* EqualSign */) ?
                            656953 /* StrictEqual */ :
                            656955 /* LooseEqual */;
                    }
                    else if (next$7 === 62 /* GreaterThan */) {
                        this$1.advance();
                        return 10 /* Arrow */;
                    }
                    return 1074003997 /* Assign */;
                }
            // `>`, `>=`, `>>`, `>>>`, `>>=`, `>>>=`
            case 62 /* GreaterThan */:
                {
                    this$1.advance();
                    var next$8 = this$1.nextChar();
                    if (next$8 === 61 /* EqualSign */) {
                        this$1.advance();
                        return 657214 /* GreaterThanOrEqual */;
                    }
                    if (next$8 !== 62 /* GreaterThan */)
                        { return 657216 /* GreaterThan */; }
                    this$1.advance();
                    if (this$1.hasNext()) {
                        next$8 = this$1.nextChar();
                        if (next$8 === 62 /* GreaterThan */) {
                            this$1.advance();
                            return this$1.consumeOpt(61 /* EqualSign */) ?
                                262176 /* LogicalShiftRightAssign */ :
                                657475 /* LogicalShiftRight */;
                        }
                        else if (next$8 === 61 /* EqualSign */) {
                            this$1.advance();
                            return 262175 /* ShiftRightAssign */;
                        }
                    }
                    return 657474 /* ShiftRight */;
                }
            // `^`, `^=`
            case 94 /* Caret */:
                this$1.advance();
                if (!this$1.consumeOpt(61 /* EqualSign */))
                    { return 656454 /* BitwiseXor */; }
                return 262183 /* BitwiseXorAssign */;
            // ``string``
            case 96 /* Backtick */:
                return this$1.scanTemplate(context, first);
            // `|`, `||`, `|=`
            case 124 /* VerticalBar */:
                {
                    this$1.advance();
                    var next$9 = this$1.nextChar();
                    if (next$9 === 124 /* VerticalBar */) {
                        this$1.advance();
                        return 4849976 /* LogicalOr */;
                    }
                    else if (next$9 === 61 /* EqualSign */) {
                        this$1.advance();
                        return 262184 /* BitwiseOrAssign */;
                    }
                    return 656197 /* BitwiseOr */;
                }
            // `(`
            case 40 /* LeftParen */:
                this$1.advance();
                return 1073872907 /* LeftParen */;
            // `)`
            case 41 /* RightParen */:
                this$1.advance();
                return 16 /* RightParen */;
            // `,`
            case 44 /* Comma */:
                this$1.advance();
                return 1073741842 /* Comma */;
            // `:`
            case 58 /* Colon */:
                this$1.advance();
                return 1073741845 /* Colon */;
            // `;`
            case 59 /* Semicolon */:
                this$1.advance();
                return 17 /* Semicolon */;
            // `?`
            case 63 /* QuestionMark */:
                this$1.advance();
                return 22 /* QuestionMark */;
            // `[`
            case 91 /* LeftBracket */:
                this$1.advance();
                return 537002003 /* LeftBracket */;
            // `]`
            case 93 /* RightBracket */:
                this$1.advance();
                return 20 /* RightBracket */;
            // `{`
            case 123 /* LeftBrace */:
                this$1.advance();
                return 537001996 /* LeftBrace */;
            // `}`
            case 125 /* RightBrace */:
                this$1.advance();
                return 1073741839 /* RightBrace */;
            // `~`
            case 126 /* Tilde */:
                this$1.advance();
                return 1179694 /* Complement */;
            // `\\u{N}var`, `a`...`z`, `A`...`Z`, `_var`, `$var`
            case 92 /* Backslash */:
            case 65 /* UpperA */:
            case 66 /* UpperB */:
            case 67 /* UpperC */:
            case 68 /* UpperD */:
            case 69 /* UpperE */:
            case 70 /* UpperF */:
            case 71 /* UpperG */:
            case 72 /* UpperH */:
            case 73 /* UpperI */:
            case 74 /* UpperJ */:
            case 75 /* UpperK */:
            case 76 /* UpperL */:
            case 77 /* UpperM */:
            case 78 /* UpperN */:
            case 79 /* UpperO */:
            case 80 /* UpperP */:
            case 81 /* UpperQ */:
            case 82 /* UpperR */:
            case 83 /* UpperS */:
            case 84 /* UpperT */:
            case 85 /* UpperU */:
            case 86 /* UpperV */:
            case 87 /* UpperW */:
            case 88 /* UpperX */:
            case 89 /* UpperY */:
            case 90 /* UpperZ */:
            case 36 /* Dollar */:
            case 95 /* Underscore */:
            case 97 /* LowerA */:
            case 98 /* LowerB */:
            case 99 /* LowerC */:
            case 100 /* LowerD */:
            case 101 /* LowerE */:
            case 102 /* LowerF */:
            case 103 /* LowerG */:
            case 104 /* LowerH */:
            case 105 /* LowerI */:
            case 106 /* LowerJ */:
            case 107 /* LowerK */:
            case 108 /* LowerL */:
            case 109 /* LowerM */:
            case 110 /* LowerN */:
            case 111 /* LowerO */:
            case 112 /* LowerP */:
            case 113 /* LowerQ */:
            case 114 /* LowerR */:
            case 115 /* LowerS */:
            case 116 /* LowerT */:
            case 117 /* LowerU */:
            case 118 /* LowerV */:
            case 119 /* LowerW */:
            case 120 /* LowerX */:
            case 121 /* LowerY */:
            case 122 /* LowerZ */:
                return this$1.scanIdentifier(context);
            default:
                if (isValidIdentifierStart(first))
                    { return this$1.scanIdentifier(context); }
                this$1.report(95 /* InvalidCharacter */, invalidCharacterMessage(first));
        }
    }
    return 0 /* EndOfSource */;
};
Parser.prototype.skipMultiLineComment = function skipMultiLineComment (context, state) {
        var this$1 = this;

    var start = this.index;
    while (this.hasNext()) {
        switch (this$1.nextChar()) {
            case 13 /* CarriageReturn */:
                state |= 1 /* NewLine */ | 4 /* LastIsCR */;
                this$1.advanceNewline();
                break;
            case 10 /* LineFeed */:
                this$1.consumeLineFeed(state);
                state = state & ~4 /* LastIsCR */ | 1 /* NewLine */;
                break;
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                state = state & ~4 /* LastIsCR */ | 1 /* NewLine */;
                this$1.advanceNewline();
                break;
            case 42 /* Asterisk */:
                {
                    this$1.advance();
                    state &= ~4 /* LastIsCR */;
                    if (this$1.consumeOpt(47 /* Slash */)) {
                        this$1.addComment(context, state | 512 /* Multiline */, start);
                        return state;
                    }
                    break;
                }
            default:
                state &= ~4 /* LastIsCR */;
                this$1.advance();
        }
    }
    this.report(77 /* UnterminatedComment */);
};
Parser.prototype.skipSingleLineComment = function skipSingleLineComment (context, state) {
        var this$1 = this;

    var start = this.index;
    scan: while (this.hasNext()) {
        switch (this$1.nextChar()) {
            case 13 /* CarriageReturn */:
                this$1.advanceNewline();
                if (this$1.hasNext() && this$1.nextChar() === 10 /* LineFeed */) {
                    this$1.index++;
                }
                break scan;
            case 10 /* LineFeed */:
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                this$1.advanceNewline();
                break scan;
            default:
                this$1.advance();
        }
    }
    this.addComment(context, state, start);
    return state;
};
Parser.prototype.addComment = function addComment (context, state, commentStart) {
    if (!(context & (16 /* OptionsComments */ | 128 /* OptionsDelegate */)))
        { return; }
    var comment = {
        type: getCommentType(state),
        value: this.source.slice(commentStart, state & 512 /* Multiline */ ? this.index - 2 : this.index),
        start: this.startIndex,
        end: this.index,
    };
    if (context & 4 /* OptionsLoc */) {
        comment.loc = {
            start: {
                line: this.startLine,
                column: this.startColumn,
            },
            end: {
                line: this.lastLine,
                column: this.column
            }
        };
    }
    if (context & 128 /* OptionsDelegate */) {
        this.delegate(comment);
    }
    this.comments.push(comment);
};
Parser.prototype.scanPrivateName = function scanPrivateName (context, ch) {
    this.advance();
    var index = this.index;
    if (!(context & 67108864 /* InClass */) || !isValidIdentifierStart(this.source.charCodeAt(index))) {
        this.index--;
        this.report(107 /* InvalidOrUnexpectedToken */);
    }
    return 118 /* Hash */;
};
Parser.prototype.scanIdentifier = function scanIdentifier (context) {
        var this$1 = this;

    var start = this.index;
    var ret = '';
    var hasEscape = false;
    loop: while (this.hasNext()) {
        var ch = this$1.nextChar();
        switch (ch) {
            case 92 /* Backslash */:
                var index = this$1.index;
                ret += this$1.source.slice(start, index);
                ret += this$1.scanUnicodeCodePointEscape(context);
                hasEscape = true;
                start = this$1.index;
                break;
            default:
                if (ch >= 55296 /* LeadSurrogateMin */ && ch <= 57343 /* TrailSurrogateMax */) {
                    this$1.nextUnicodeChar();
                }
                else if (!isIdentifierPart(ch))
                    { break loop; }
                this$1.advance();
        }
    }
    if (start < this.index)
        { ret += this.source.slice(start, this.index); }
    var len = ret.length;
    this.tokenValue = ret;
    if (hasEscape)
        { this.flags |= 512 /* HasEscapedKeyword */; }
    // Keywords are between 2 and 11 characters long and start with a lowercase letter
    if (len >= 2 && len <= 11) {
        if (context & 1048576 /* ValidateEscape */ && hasEscape) {
            this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
        }
        var token = descKeyword(ret);
        if (token > 0)
            { return token; }
    }
    return 16908289 /* Identifier */;
};
Parser.prototype.scanUnicodeCodePointEscape = function scanUnicodeCodePointEscape (context) {
    var index = this.index;
    if (index + 5 < this.source.length) {
        if (this.source.charCodeAt(index + 1) !== 117 /* LowerU */) {
            this.tolerate(context, 0 /* Unexpected */);
        }
        this.index += 2;
        this.column += 2;
        var code = this.scanIdentifierUnicodeEscape();
        if (code >= 55296 /* LeadSurrogateMin */ && code <= 56320 /* TrailSurrogateMin */) {
            this.report(37 /* UnexpectedSurrogate */);
        }
        if (!isIdentifierPart(code)) {
            this.tolerate(context, 38 /* InvalidUnicodeEscapeSequence */);
        }
        return fromCodePoint(code);
    }
    this.tolerate(context, 0 /* Unexpected */);
};
Parser.prototype.scanIdentifierUnicodeEscape = function scanIdentifierUnicodeEscape () {
        var this$1 = this;

    // Accept both \uxxxx and \u{xxxxxx}. In the latter case, the number of
    // hex digits between { } is arbitrary. \ and u have already been read.
    var ch = this.nextChar();
    var codePoint = 0;
    // '\u{DDDDDDDD}'
    if (ch === 123 /* LeftBrace */) {
        ch = this.readNext(ch, 34 /* InvalidHexEscapeSequence */);
        var digit = toHex(ch);
        while (digit >= 0) {
            codePoint = (codePoint << 4) | digit;
            if (codePoint > 1114111 /* LastUnicodeChar */) {
                this$1.report(106 /* UndefinedUnicodeCodePoint */);
            }
            this$1.advance();
            digit = toHex(this$1.nextChar());
        }
        if (this.nextChar() !== 125 /* RightBrace */) {
            this.report(34 /* InvalidHexEscapeSequence */);
        }
        this.consumeOpt(125 /* RightBrace */);
        // '\uDDDD'
    }
    else {
        for (var i = 0; i < 4; i++) {
            ch = this$1.nextChar();
            var digit$1 = toHex(ch);
            if (digit$1 < 0)
                { this$1.report(34 /* InvalidHexEscapeSequence */); }
            codePoint = (codePoint << 4) | digit$1;
            this$1.advance();
        }
    }
    return codePoint;
};
Parser.prototype.scanDecimalAsSmi = function scanDecimalAsSmi (context, state) {
        var this$1 = this;

    // TODO! Fix this as soon as numeric separators reach stage 4
    if (context & 1 /* OptionsNext */) {
        return this.scanDecimalDigitsOrFragment(context, state);
    }
    var value = 0;
    loop: while (this.hasNext()) {
        var ch = this$1.nextChar();
        switch (ch) {
            case 48 /* Zero */:
            case 49 /* One */:
            case 50 /* Two */:
            case 51 /* Three */:
            case 52 /* Four */:
            case 53 /* Five */:
            case 54 /* Six */:
            case 55 /* Seven */:
            case 56 /* Eight */:
            case 57 /* Nine */:
                value = value * 10 + (ch - 48 /* Zero */);
                this$1.advance();
                break;
            default:
                break loop;
        }
    }
    return value;
};
Parser.prototype.scanDecimalDigitsOrFragment = function scanDecimalDigitsOrFragment (context, state) {
        var this$1 = this;

    var start = this.index;
    var ret = '';
    loop: while (this.hasNext()) {
        switch (this$1.nextChar()) {
            case 95 /* Underscore */:
                {
                    if (!(context & 1 /* OptionsNext */))
                        { break; }
                    if (state & 256 /* HasNumericSeparator */) {
                        state = state & ~256 /* HasNumericSeparator */ | 512 /* isPreviousTokenSeparator */;
                        ret += this$1.source.substring(start, this$1.index);
                    }
                    else if (state & 512 /* isPreviousTokenSeparator */) {
                        this$1.tolerate(context, 115 /* ContinuousNumericSeparator */);
                    }
                    else {
                        this$1.tolerate(context, 79 /* InvalidNumericSeparators */);
                    }
                    this$1.advance();
                    start = this$1.index;
                    continue;
                }
            case 48 /* Zero */:
            case 49 /* One */:
            case 50 /* Two */:
            case 51 /* Three */:
            case 52 /* Four */:
            case 53 /* Five */:
            case 54 /* Six */:
            case 55 /* Seven */:
            case 56 /* Eight */:
            case 57 /* Nine */:
                state = state & ~512 /* isPreviousTokenSeparator */ | 256 /* HasNumericSeparator */;
                this$1.advance();
                break;
            default:
                break loop;
        }
    }
    if (state & 512 /* isPreviousTokenSeparator */) {
        this.tolerate(context, 79 /* InvalidNumericSeparators */);
    }
    return ret + this.source.substring(start, this.index);
};
Parser.prototype.scanNumeric = function scanNumeric (context, state, ch) {
        var this$1 = this;

    var value = 0;
    if (ch === 48 /* Zero */) {
        var index = this.index + 1;
        var column = this.column + 1;
        var next = this.source.charCodeAt(index);
        switch (next) {
            case 88 /* UpperX */:
            case 120 /* LowerX */:
                {
                    state = 4 /* Hexadecimal */;
                    index++;
                    column++;
                    var ch$1 = this.source.charCodeAt(index);
                    value = toHex(ch$1);
                    if (value < 0)
                        { this.tolerate(context, 81 /* MissingHexDigits */); }
                    index++;
                    column++;
                    while (index < this.source.length) {
                        ch$1 = this$1.source.charCodeAt(index);
                        if (ch$1 === 95 /* Underscore */) {
                            index++;
                            column++;
                            // E.g. '__'
                            if (this$1.source.charCodeAt(index) === 95 /* Underscore */) {
                                this$1.tolerate(context, 79 /* InvalidNumericSeparators */);
                            }
                            state |= 256 /* HasNumericSeparator */;
                            continue;
                        }
                        state &= ~256 /* HasNumericSeparator */;
                        var digit = toHex(ch$1);
                        if (digit < 0)
                            { break; }
                        value = value * 16 + digit;
                        index++;
                        column++;
                    }
                    break;
                }
            case 66 /* UpperB */:
            case 98 /* LowerB */:
            case 79 /* UpperO */:
            case 111 /* LowerO */:
                {
                    var base = 2;
                    var errorMessage = 83 /* MissingBinaryDigits */;
                    state = 32 /* Binary */;
                    if (next === 79 /* UpperO */ || next === 111 /* LowerO */) {
                        base = 8;
                        state = 8 /* Octal */;
                        errorMessage = 82 /* MissingOctalDigits */;
                    }
                    index++;
                    column++;
                    var digits = 0;
                    while (index < this.source.length) {
                        ch = this$1.source.charCodeAt(index);
                        if (ch === 95 /* Underscore */) {
                            index++;
                            column++;
                            // E.g. '__'
                            if (this$1.source.charCodeAt(index) === 95 /* Underscore */) {
                                this$1.tolerate(context, 79 /* InvalidNumericSeparators */);
                            }
                            state |= 256 /* HasNumericSeparator */;
                            continue;
                        }
                        state &= ~256 /* HasNumericSeparator */;
                        var converted = ch - 48 /* Zero */;
                        if (!(ch >= 48 /* Zero */ && ch <= 57 /* Nine */) || converted >= base)
                            { break; }
                        value = value * base + converted;
                        index++;
                        column++;
                        digits++;
                    }
                    if (digits === 0)
                        { this.report(errorMessage); }
                    break;
                }
            default:
                state = 16 /* ImplicitOctal */;
                if (next === 56 /* Eight */ || next === 57 /* Nine */) {
                    this.flags |= 64 /* Octal */;
                }
                if (next >= 48 /* Zero */ && next <= 55 /* Seven */ ||
                    (context & 1 /* OptionsNext */ && next === 95 /* Underscore */)) {
                    this.flags |= 64 /* Octal */;
                    while (index < this.source.length) {
                        ch = this$1.source.charCodeAt(index);
                        if (ch === 95 /* Underscore */) {
                            index++;
                            column++;
                            // E.g. '__'
                            if (this$1.source.charCodeAt(index) === 95 /* Underscore */) {
                                this$1.tolerate(context, 79 /* InvalidNumericSeparators */);
                            }
                            state |= 256 /* HasNumericSeparator */;
                            continue;
                        }
                        state &= ~256 /* HasNumericSeparator */;
                        if (ch === 56 /* Eight */ || ch === 57 /* Nine */) {
                            state = 2048 /* EigthOrNine */ | 64 /* Float */;
                            break;
                        }
                        if (ch < 48 /* Zero */ || ch > 55 /* Seven */)
                            { break; }
                        value = value * 8 + (ch - 48 /* Zero */);
                        index++;
                        column++;
                    }
                }
                else {
                    state = 1 /* Decimal */;
                }
        }
        // In cases where '8' or '9' are part of the implicit octal
        // value - e.g. '0128' - we would need to reset the index and column
        // values to the initial position so we can re-scan these
        // as a decimal value with leading zero.
        if (state & 2048 /* EigthOrNine */) {
            this.index = this.startIndex;
            this.column = this.startColumn;
            this.flags |= 64 /* Octal */;
            value = this.scanDecimalDigitsOrFragment(context, state);
        }
        else {
            if (state & 256 /* HasNumericSeparator */) {
                this.report(79 /* InvalidNumericSeparators */);
            }
            this.index = index;
            this.column = column;
        }
    }
    if (state & 2113 /* AllowDecimalImplicitOrFloat */) {
        if (state & 1 /* Decimal */)
            { value = this.scanDecimalAsSmi(context, state); }
        if (this.consumeOpt(46 /* Period */)) {
            state |= 64 /* Float */;
            if (this.nextChar() === 95 /* Underscore */)
                { this.report(79 /* InvalidNumericSeparators */); }
            value = value + '.' + this.scanDecimalDigitsOrFragment(context, state);
        }
    }
    ch = this.nextChar();
    var end = this.index;
    if (context & 1 /* OptionsNext */ && this.consumeOpt(110 /* LowerN */)) {
        // It is a Syntax Error if the MV is not an integer.
        if (state & (64 /* Float */ | 16 /* ImplicitOctal */))
            { this.tolerate(context, 80 /* InvalidBigIntLiteral */); }
        state |= 1024 /* BigInt */;
    }
    else if (this.consumeOpt(69 /* UpperE */) || this.consumeOpt(101 /* LowerE */)) {
        var next$1 = this.nextChar();
        if (next$1 === 45 /* Hyphen */ || next$1 === 43 /* Plus */) {
            this.advance();
            next$1 = this.nextChar();
        }
        if (!isDecimalDigit(next$1)) {
            this.tolerate(context, 97 /* NonNumberAfterExponentIndicator */);
        }
        var preNumericPart = this.source.substring(end, this.index);
        value += preNumericPart + this.scanDecimalDigitsOrFragment(context, state);
    }
    if (isValidIdentifierStart(this.nextChar())) {
        this.tolerate(context, 107 /* InvalidOrUnexpectedToken */);
    }
    // Note! To be compatible  with other parsers, 'parseFloat'are used for
    // floating numbers - e.g. '0008.324'. There are really no need to use it.
    if (state & 64 /* Float */)
        { value = parseFloat(value); }
    this.tokenValue = value;
    if (context & 8 /* OptionsRaw */) {
        this.tokenRaw = this.source.slice(this.startIndex, this.index);
    }
    return state & 1024 /* BigInt */ ? 120 /* BigInt */ : 131074 /* NumericLiteral */;
};
Parser.prototype.scanRegularExpression = function scanRegularExpression (context) {
        var this$1 = this;

    var bodyStart = this.startIndex + 1;
    var preparseState = 0 /* Empty */;
    loop: while (true) {
        var ch = this$1.nextChar();
        this$1.advance();
        if (preparseState & 1 /* Escape */) {
            preparseState &= ~1 /* Escape */;
        }
        else {
            switch (ch) {
                case 47 /* Slash */:
                    if (!preparseState)
                        { break loop; }
                    break;
                case 92 /* Backslash */:
                    preparseState |= 1 /* Escape */;
                    break;
                case 91 /* LeftBracket */:
                    preparseState |= 2 /* Class */;
                    break;
                case 93 /* RightBracket */:
                    preparseState &= 1 /* Escape */;
                    break;
                case 13 /* CarriageReturn */:
                case 10 /* LineFeed */:
                case 8232 /* LineSeparator */:
                case 8233 /* ParagraphSeparator */:
                    this$1.report(74 /* UnexpectedNewlineRegExp */);
                default: // ignore
            }
        }
        if (!this$1.hasNext())
            { this$1.report(72 /* UnterminatedRegExp */); }
    }
    var bodyEnd = this.index - 1;
    var flagsStart = this.index;
    var mask = 0 /* None */;
    // Scan regular expression flags
    loop: while (this.hasNext()) {
        var code = this$1.nextChar();
        switch (code) {
            case 103 /* LowerG */:
                if (mask & 2 /* Global */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 'g'); }
                mask |= 2 /* Global */;
                break;
            case 105 /* LowerI */:
                if (mask & 1 /* IgnoreCase */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 'i'); }
                mask |= 1 /* IgnoreCase */;
                break;
            case 109 /* LowerM */:
                if (mask & 4 /* Multiline */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 'm'); }
                mask |= 4 /* Multiline */;
                break;
            case 117 /* LowerU */:
                if (mask & 8 /* Unicode */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 'u'); }
                mask |= 8 /* Unicode */;
                break;
            case 121 /* LowerY */:
                if (mask & 16 /* Sticky */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 'y'); }
                mask |= 16 /* Sticky */;
                break;
            case 115 /* LowerS */:
                if (mask & 32 /* DotAll */)
                    { this$1.tolerate(context, 75 /* DuplicateRegExpFlag */, 's'); }
                mask |= 32 /* DotAll */;
                break;
            default:
                if (code >= 0xd800 && code <= 0xdc00)
                    { code = this$1.nextUnicodeChar(); }
                if (!isIdentifierPart(code))
                    { break loop; }
                this$1.tolerate(context, 76 /* UnexpectedTokenRegExpFlag */);
        }
        this$1.advance();
    }
    var flagsEnd = this.index;
    var pattern = this.source.slice(bodyStart, bodyEnd);
    var flags = this.source.slice(flagsStart, flagsEnd);
    this.tokenRegExp = {
        pattern: pattern,
        flags: flags
    };
    this.tokenValue = this.testRegExp(pattern, flags, mask);
    if (context & 8 /* OptionsRaw */)
        { this.storeRaw(this.startIndex); }
    return 131076 /* RegularExpression */;
};
Parser.prototype.testRegExp = function testRegExp (pattern, flags, mask) {
    try {
    }
    catch (e) {
        this.report(73 /* UnexpectedTokenRegExp */);
    }
    try {
        return new RegExp(pattern, flags);
    }
    catch (exception) {
        return null;
    }
};
Parser.prototype.scanString = function scanString (context, quote) {
        var this$1 = this;

    var start = this.index;
    var lastChar = this.lastChar;
    var ret = '';
    var state = 0 /* None */;
    var ch = this.readNext(quote); // Consume the quote
    while (ch !== quote) {
        switch (ch) {
            case 13 /* CarriageReturn */:
            case 10 /* LineFeed */:
                this$1.report(35 /* UnterminatedString */);
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                if (context & 1 /* OptionsNext */)
                    { this$1.advance(); }
                this$1.report(35 /* UnterminatedString */);
            case 92 /* Backslash */:
                ch = this$1.readNext(ch);
                state |= 16 /* Escape */;
                if (ch >= 128) {
                    ret += fromCodePoint(ch);
                }
                else {
                    this$1.lastChar = ch;
                    var code = this$1.scanEscapeSequence(context, ch);
                    if (code >= 0)
                        { ret += fromCodePoint(code); }
                    else
                        { this$1.throwStringError(context, code); }
                    ch = this$1.lastChar;
                }
                break;
            default:
                ret += fromCodePoint(ch);
        }
        ch = this$1.readNext(ch);
    }
    this.consumeUnicode(ch);
    this.storeRaw(start);
    if (!(state & 16 /* Escape */) && ret === 'use strict') {
        this.flags |= 1024 /* StrictDirective */;
    }
    this.tokenValue = ret;
    this.lastChar = lastChar;
    return 131075 /* StringLiteral */;
};
Parser.prototype.throwStringError = function throwStringError (context, code) {
    switch (code) {
        case -1 /* Empty */:
            return;
        case -2 /* StrictOctal */:
            this.tolerate(context, context & 2048 /* TaggedTemplate */ ?
                31 /* TemplateOctalLiteral */ :
                32 /* StrictOctalEscape */);
        case -3 /* EightOrNine */:
            this.tolerate(context, 33 /* InvalidEightAndNine */);
        case -4 /* InvalidHex */:
            this.tolerate(context, 34 /* InvalidHexEscapeSequence */);
        case -5 /* OutOfRange */:
            this.tolerate(context, 30 /* UnicodeOutOfRange */);
        default:
    }
};
Parser.prototype.scanEscapeSequence = function scanEscapeSequence (context, first) {
        var this$1 = this;

    switch (first) {
        case 98 /* LowerB */:
            return 8 /* Backspace */;
        case 102 /* LowerF */:
            return 12 /* FormFeed */;
        case 114 /* LowerR */:
            return 13 /* CarriageReturn */;
        case 110 /* LowerN */:
            return 10 /* LineFeed */;
        case 116 /* LowerT */:
            return 9 /* Tab */;
        case 118 /* LowerV */:
            return 11 /* VerticalTab */;
        case 13 /* CarriageReturn */:
        case 10 /* LineFeed */:
        case 8232 /* LineSeparator */:
        case 8233 /* ParagraphSeparator */:
            this.column = -1;
            this.line++;
            return -1 /* Empty */;
        case 48 /* Zero */:
        case 49 /* One */:
        case 50 /* Two */:
        case 51 /* Three */:
            {
                // 1 to 3 octal digits
                var code = first - 48 /* Zero */;
                var index = this.index + 1;
                var column = this.column + 1;
                var next = this.source.charCodeAt(index);
                if (next < 48 /* Zero */ || next > 55 /* Seven */) {
                    // Strict mode code allows only \0, then a non-digit.
                    if (code !== 0 || next === 56 /* Eight */ || next === 57 /* Nine */) {
                        if (context & 512 /* Strict */)
                            { return -2 /* StrictOctal */; }
                        this.flags |= 64 /* Octal */;
                    }
                }
                else if (context & 512 /* Strict */) {
                    return -2 /* StrictOctal */;
                }
                else {
                    this.lastChar = next;
                    code = code * 8 + (next - 48 /* Zero */);
                    index++;
                    column++;
                    if (index < this.source.length) {
                        next = this.source.charCodeAt(index);
                        if (next >= 48 /* Zero */ && next <= 55 /* Seven */) {
                            this.lastChar = next;
                            code = code * 8 + (next - 48 /* Zero */);
                            index++;
                            column++;
                        }
                    }
                    this.index = index - 1;
                    this.column = column - 1;
                }
                return code;
            }
        case 52 /* Four */:
        case 53 /* Five */:
        case 54 /* Six */:
        case 55 /* Seven */:
            {
                // 1 to 2 octal digits
                if (context & 512 /* Strict */)
                    { return -2 /* StrictOctal */; }
                var code$1 = first - 48 /* Zero */;
                var index$1 = this.index + 1;
                var column$1 = this.column + 1;
                if (index$1 < this.source.length) {
                    var next$1 = this.source.charCodeAt(index$1);
                    if (next$1 >= 48 /* Zero */ && next$1 <= 55 /* Seven */) {
                        code$1 = code$1 * 8 + (next$1 - 48 /* Zero */);
                        this.lastChar = next$1;
                        this.index = index$1;
                        this.column = column$1;
                    }
                }
                return code$1;
            }
        // `8`, `9` (invalid escapes)
        case 56 /* Eight */:
        case 57 /* Nine */:
            return -3 /* EightOrNine */;
        // ASCII escapes
        case 120 /* LowerX */:
            {
                var ch1 = this.lastChar = this.readNext(first);
                var hi = toHex(ch1);
                if (hi < 0)
                    { return -4 /* InvalidHex */; }
                var ch2 = this.lastChar = this.readNext(ch1);
                var lo = toHex(ch2);
                if (lo < 0)
                    { return -4 /* InvalidHex */; }
                return hi << 4 | lo;
            }
        // Unicode character specification.
        case 117 /* LowerU */:
            {
                var ch = this.lastChar = this.readNext(first, 105 /* MissingUAfterSlash */);
                if (ch === 123 /* LeftBrace */) {
                    ch = this.lastChar = this.readNext(ch);
                    var code$2 = toHex(ch);
                    if (code$2 < 0)
                        { return -4 /* InvalidHex */; }
                    ch = this.lastChar = this.readNext(ch);
                    while (ch !== 125 /* RightBrace */) {
                        var digit = toHex(ch);
                        if (digit < 0)
                            { return -4 /* InvalidHex */; }
                        code$2 = code$2 * 16 + digit;
                        // Code point out of bounds
                        if (code$2 > 1114111 /* LastUnicodeChar */)
                            { return -5 /* OutOfRange */; }
                        ch = this$1.lastChar = this$1.readNext(ch);
                    }
                    return code$2;
                }
                else {
                    // \uNNNN
                    var codePoint = toHex(ch);
                    if (codePoint < 0)
                        { return -4 /* InvalidHex */; }
                    for (var i = 0; i < 3; i++) {
                        ch = this$1.lastChar = this$1.readNext(ch);
                        var digit$1 = toHex(ch);
                        if (digit$1 < 0)
                            { return -4 /* InvalidHex */; }
                        codePoint = codePoint * 16 + digit$1;
                    }
                    return codePoint;
                }
            }
        default:
            return this.nextUnicodeChar();
    }
};
Parser.prototype.consumeTemplateBrace = function consumeTemplateBrace (context) {
    if (!this.hasNext())
        { this.tolerate(context, 87 /* UnterminatedTemplate */); }
    // Upon reaching a '}', consume it and rewind the scanner state
    this.index--;
    this.column--;
    return this.scanTemplate(context, 125 /* RightBrace */);
};
Parser.prototype.scanTemplate = function scanTemplate (context, first) {
        var this$1 = this;

    var start = this.index;
    var lastChar = this.lastChar;
    var tail = true;
    var ret = '';
    var ch = this.readNext(first);
    loop: while (ch !== 96 /* Backtick */) {
        switch (ch) {
            case 36 /* Dollar */:
                {
                    var index = this$1.index + 1;
                    if (index < this$1.source.length &&
                        this$1.source.charCodeAt(index) === 123 /* LeftBrace */) {
                        this$1.index = index;
                        this$1.column++;
                        tail = false;
                        break loop;
                    }
                    ret += '$';
                    break;
                }
            case 92 /* Backslash */:
                {
                    ch = this$1.readNext(ch);
                    if (ch >= 128) {
                        ret += fromCodePoint(ch);
                    }
                    else {
                        this$1.lastChar = ch;
                        var code = this$1.scanEscapeSequence(context | 512 /* Strict */, ch);
                        if (code >= 0) {
                            ret += fromCodePoint(code);
                        }
                        else if (code !== -1 /* Empty */ && context & 2048 /* TaggedTemplate */) {
                            ret = undefined;
                            ch = this$1.scanLooserTemplateSegment(this$1.lastChar);
                            if (ch < 0) {
                                ch = -ch;
                                tail = false;
                            }
                            break loop;
                        }
                        else {
                            this$1.throwStringError(context | 2048 /* TaggedTemplate */, code);
                        }
                        ch = this$1.lastChar;
                    }
                    break;
                }
            case 13 /* CarriageReturn */:
                {
                    if (this$1.hasNext() && this$1.nextChar() === 10 /* LineFeed */) {
                        if (ret != null)
                            { ret += fromCodePoint(ch); }
                        ch = this$1.nextChar();
                        this$1.index++;
                    }
                }
            // falls through
            case 10 /* LineFeed */:
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                this$1.column = -1;
                this$1.line++;
            // falls through
            default:
                if (ret != null)
                    { ret += fromCodePoint(ch); }
        }
        ch = this$1.readNext(ch);
    }
    this.consumeUnicode(ch);
    this.tokenValue = ret;
    this.lastChar = lastChar;
    if (tail) {
        this.tokenRaw = this.source.slice(start + 1, this.index - 1);
        return 131081 /* TemplateTail */;
    }
    else {
        this.tokenRaw = this.source.slice(start + 1, this.index - 2);
        return 131080 /* TemplateCont */;
    }
};
Parser.prototype.scanLooserTemplateSegment = function scanLooserTemplateSegment (ch) {
        var this$1 = this;

    while (ch !== 96 /* Backtick */) {
        if (ch === 36 /* Dollar */) {
            var index = this$1.index + 1;
            if (index < this$1.source.length &&
                this$1.source.charCodeAt(index) === 123 /* LeftBrace */) {
                this$1.index = index;
                this$1.column++;
                return -ch;
            }
        }
        // Skip '\' and continue to scan the template token to search
        // for the end, without validating any escape sequences
        ch = this$1.readNext(ch);
    }
    return ch;
};
Parser.prototype.lookahead = function lookahead () {
    return {
        index: this.index,
        column: this.column,
        line: this.line,
        startLine: this.startLine,
        lastLine: this.lastLine,
        startColumn: this.startColumn,
        lastColumn: this.lastColumn,
        token: this.token,
        tokenValue: this.tokenValue,
        tokenRaw: this.tokenRaw,
        startIndex: this.startIndex,
        lastIndex: this.lastIndex,
        tokenRegExp: this.tokenRegExp,
        flags: this.flags
    };
};
Parser.prototype.rewindState = function rewindState (state) {
    this.index = state.index;
    this.column = state.column;
    this.line = state.line;
    this.token = state.token;
    this.tokenValue = state.tokenValue;
    this.startIndex = state.startIndex;
    this.lastIndex = state.lastIndex;
    this.lastLine = state.lastLine;
    this.startLine = state.startLine;
    this.startColumn = state.startColumn;
    this.lastColumn = state.lastColumn;
    this.tokenRegExp = state.tokenRegExp;
    this.tokenRaw = state.tokenRaw;
    this.flags = state.flags;
};
Parser.prototype.getLocation = function getLocation () {
    return {
        line: this.startLine,
        column: this.startColumn,
        index: this.startIndex,
    };
};
// https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
Parser.prototype.parseDirective = function parseDirective (context) {
    var pos = this.getLocation();
    var directive = this.tokenRaw.slice(1, -1);
    var expr = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ExpressionStatement',
        expression: expr,
        directive: directive
    });
};
Parser.prototype.consumeSemicolon = function consumeSemicolon (context) {
    switch (this.token) {
        case 17 /* Semicolon */:
            this.nextToken(context);
        case 1073741839 /* RightBrace */:
        case 0 /* EndOfSource */:
            return true;
        default:
            if (this.flags & 1 /* LineTerminator */)
                { return true; }
            this.reportUnexpectedTokenOrKeyword();
    }
};
Parser.prototype.expect = function expect (context, t) {
    if (this.token !== t) {
        this.reportUnexpectedTokenOrKeyword();
    }
    this.nextToken(context);
};
Parser.prototype.consume = function consume (context, t) {
    if (this.token === t) {
        this.nextToken(context);
        return true;
    }
    return false;
};
Parser.prototype.validateParams = function validateParams (context, params) {
        var this$1 = this;

    var paramSet = map.create();
    for (var i = 0; i < params.length; i++) {
        var key = '@' + params[i];
        if (map.get(paramSet, key)) {
            this$1.tolerate(context, 8 /* InvalidDuplicateArgs */, params[i]);
        }
        else
            { map.set(paramSet, key, true); }
    }
};
// 'import', 'import.meta'
Parser.prototype.nextTokenIsLeftParenOrPeriod = function nextTokenIsLeftParenOrPeriod (context) {
    var savedState = this.lookahead();
    var t = this.nextToken(context);
    this.rewindState(savedState);
    return t === 1073872907 /* LeftParen */ || t === 13 /* Period */;
};
Parser.prototype.nextTokenIsIdentifierOrKeywordOrGreaterThan = function nextTokenIsIdentifierOrKeywordOrGreaterThan (context) {
    var savedState = this.lookahead();
    var t = this.nextToken(context);
    this.rewindState(savedState);
    return !!(t & (16777216 /* IsIdentifier */ | 4096 /* Keyword */)) || t === 657216 /* GreaterThan */;
};
Parser.prototype.nextTokenIsFuncKeywordOnSameLine = function nextTokenIsFuncKeywordOnSameLine (context) {
    var savedState = this.lookahead();
    var t = this.nextToken(context);
    var flags = this.flags;
    this.rewindState(savedState);
    return !(flags & 1 /* LineTerminator */) && t === 143448 /* FunctionKeyword */;
};
Parser.prototype.isLexical = function isLexical (context) {
    var savedState = this.lookahead();
    var savedFlag = this.flags;
    var t = this.nextToken(context);
    this.rewindState(savedState);
    return !!(t & (16777216 /* IsIdentifier */ | 536870912 /* IsBindingPattern */ | 268435456 /* IsYield */ | 134217728 /* IsAwait */) ||
        t === 151624 /* LetKeyword */ ||
        (t & 69632 /* Contextual */) === 69632 /* Contextual */) && !(savedFlag & 512 /* HasEscapedKeyword */);
};
Parser.prototype.finishNode = function finishNode (context, pos, node) {
    if (context & 2 /* OptionsRanges */) {
        node.start = pos.index;
        node.end = this.lastIndex;
    }
    if (context & 4 /* OptionsLoc */) {
        node.loc = {
            start: {
                line: pos.line,
                column: pos.column,
            },
            end: {
                line: this.lastLine,
                column: this.lastColumn
            }
        };
        if (this.sourceFile) {
            node.loc.source = this.sourceFile;
        }
    }
    if (context & 128 /* OptionsDelegate */) {
        this.delegate(node);
    }
    return node;
};
Parser.prototype.report = function report (type) {
        var value = [], len = arguments.length - 1;
        while ( len-- > 0 ) value[ len ] = arguments[ len + 1 ];

    throw createError.apply(void 0, [ type, this.lastIndex, this.lastLine, this.lastColumn, this.errorLocation ].concat( value ));
};
Parser.prototype.tolerate = function tolerate (context, type) {
        var value = [], len = arguments.length - 2;
        while ( len-- > 0 ) value[ len ] = arguments[ len + 2 ];

    var error = createError.apply(void 0, [ type, this.lastIndex, this.lastLine, this.lastColumn, this.errorLocation ].concat( value ));
    if (!(context & 32 /* OptionsTolerate */))
        { throw error; }
    this.errors.push(error);
};
Parser.prototype.reportUnexpectedTokenOrKeyword = function reportUnexpectedTokenOrKeyword (t) {
        if ( t === void 0 ) t = this.token;

    this.report((t & (12288 /* Reserved */ | 20480 /* FutureReserved */)) ?
        100 /* UnexpectedKeyword */ :
        1 /* UnexpectedToken */, tokenDesc(this.token));
};
Parser.prototype.nextToken = function nextToken (context) {
    if (this.flags & 1024 /* StrictDirective */)
        { context |= 512 /* Strict */; }
    this.lastIndex = this.index;
    this.lastLine = this.line;
    this.lastColumn = this.column;
    this.token = this.scan(context);
    return this.token;
};
Parser.prototype.parseExportDefault = function parseExportDefault (context, pos) {
    this.expect(context | 1048576 /* ValidateEscape */, 12368 /* DefaultKeyword */);
    var declaration;
    switch (this.token) {
        // export default HoistableDeclaration[Default]
        case 143448 /* FunctionKeyword */:
            declaration = this.parseFunctionDeclaration(context | 134217728 /* RequireIdentifier */);
            break;
        // export default ClassDeclaration[Default]
        case 143437 /* ClassKeyword */:
            declaration = this.parseClass(context & ~256 /* AllowIn */ | 134217728 /* RequireIdentifier */);
            break;
        // export default HoistableDeclaration[Default]
        case 33624173 /* AsyncKeyword */:
            {
                if (this.nextTokenIsFuncKeywordOnSameLine(context)) {
                    declaration = this.parseFunctionDeclaration(context | 134217728 /* RequireIdentifier */);
                    break;
                }
            }
        // falls through
        default:
            {
                // export default [lookahead  {function, class}] AssignmentExpression[In] ;
                declaration = this.parseAssignmentExpression(context | 256 /* AllowIn */);
                this.consumeSemicolon(context);
            }
    }
    return this.finishNode(context, pos, {
        type: 'ExportDefaultDeclaration',
        declaration: declaration
    });
};
Parser.prototype.parseExportDeclaration = function parseExportDeclaration (context) {
        var this$1 = this;

    // ExportDeclaration:
    //'export' '*' 'from' ModuleSpecifier ';'
    //'export' ExportClause ('from' ModuleSpecifier)? ';'
    //'export' VariableStatement
    //'export' Declaration
    //'export' 'default' ... (handled in ParseExportDefault)
    var pos = this.getLocation();
    var specifiers = [];
    var source = null;
    var declaration = null;
    this.expect(context | 1048576 /* ValidateEscape */, 12371 /* ExportKeyword */);
    switch (this.token) {
        // export * FromClause ;
        case 67766835 /* Multiply */:
            return this.parseExportAllDeclaration(context, pos);
        case 12368 /* DefaultKeyword */:
            return this.parseExportDefault(context, pos);
        case 537001996 /* LeftBrace */:
            {
                // export ExportClause FromClause ;
                // export ExportClause ;
                this.expect(context, 537001996 /* LeftBrace */);
                var t = this.token;
                var hasKeywordForLocalBindings = false;
                while (this.token !== 1073741839 /* RightBrace */) {
                    if (this$1.token & 12288 /* Reserved */) {
                        this$1.errorLocation = this$1.getLocation();
                        t = this$1.token;
                        hasKeywordForLocalBindings = true;
                    }
                    specifiers.push(this$1.parseNamedExportDeclaration(context));
                    if (this$1.token !== 1073741839 /* RightBrace */)
                        { this$1.expect(context, 1073741842 /* Comma */); }
                }
                this.expect(context | 1048576 /* ValidateEscape */, 1073741839 /* RightBrace */);
                if (this.token === 69746 /* FromKeyword */) {
                    source = this.parseModuleSpecifier(context);
                }
                else if (hasKeywordForLocalBindings) {
                    this.tolerate(context, 100 /* UnexpectedKeyword */, tokenDesc(t));
                }
                this.consumeSemicolon(context);
                break;
            }
        // export ClassDeclaration
        case 143437 /* ClassKeyword */:
            declaration = this.parseClass(context & ~256 /* AllowIn */);
            break;
        // export LexicalDeclaration
        case 143433 /* ConstKeyword */:
            declaration = this.parseVariableStatement(context);
            break;
        // export LexicalDeclaration
        case 151624 /* LetKeyword */:
            declaration = this.parseVariableStatement(context);
            break;
        // export VariableDeclaration
        case 143431 /* VarKeyword */:
            declaration = this.parseVariableStatement(context);
            break;
        // export HoistableDeclaration
        case 143448 /* FunctionKeyword */:
            declaration = this.parseFunctionDeclaration(context);
            break;
        // export HoistableDeclaration
        case 33624173 /* AsyncKeyword */:
            if (this.nextTokenIsFuncKeywordOnSameLine(context)) {
                declaration = this.parseFunctionDeclaration(context);
                break;
            }
        // Falls through
        default:
            this.report(0 /* Unexpected */);
    }
    return this.finishNode(context, pos, {
        type: 'ExportNamedDeclaration',
        source: source,
        specifiers: specifiers,
        declaration: declaration
    });
};
Parser.prototype.parseNamedExportDeclaration = function parseNamedExportDeclaration (context) {
    var pos = this.getLocation();
    var local = this.parseIdentifierName(context | 1048576 /* ValidateEscape */, this.token);
    var exported = local;
    if (this.consume(context, 69740 /* AsKeyword */)) {
        exported = this.parseIdentifierName(context, this.token);
    }
    return this.finishNode(context, pos, {
        type: 'ExportSpecifier',
        local: local,
        exported: exported
    });
};
Parser.prototype.parseExportAllDeclaration = function parseExportAllDeclaration (context, pos) {
    this.expect(context, 67766835 /* Multiply */);
    var source = this.parseModuleSpecifier(context);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ExportAllDeclaration',
        source: source
    });
};
Parser.prototype.parseModuleSpecifier = function parseModuleSpecifier (context) {
    // ModuleSpecifier :
    //StringLiteral
    this.expect(context, 69746 /* FromKeyword */);
    if (this.token !== 131075 /* StringLiteral */)
        { this.report(84 /* InvalidModuleSpecifier */); }
    return this.parseLiteral(context);
};
// import {<foo as bar>} ...;
Parser.prototype.parseImportSpecifier = function parseImportSpecifier (context) {
    var pos = this.getLocation();
    var t = this.token;
    var imported = this.parseIdentifierName(context | 1048576 /* ValidateEscape */, t);
    var local;
    if (this.token & 69632 /* Contextual */) {
        this.expect(context, 69740 /* AsKeyword */);
        local = this.parseBindingIdentifier(context);
    }
    else {
        // Invalid: 'import { arguments } from './foo';'
        if (t & 8388608 /* IsEvalArguments */ && this.token === 1073741839 /* RightBrace */) {
            this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */);
        }
        else if (t & 12288 /* Reserved */)
            { this.tolerate(context, 100 /* UnexpectedKeyword */, tokenDesc(t)); }
        local = imported;
    }
    return this.finishNode(context, pos, {
        type: 'ImportSpecifier',
        local: local,
        imported: imported
    });
};
// {foo, bar as bas}
Parser.prototype.parseNamedImport = function parseNamedImport (context, specifiers) {
        var this$1 = this;

    this.expect(context, 537001996 /* LeftBrace */);
    while (this.token !== 1073741839 /* RightBrace */) {
        // only accepts identifiers or keywords
        specifiers.push(this$1.parseImportSpecifier(context));
        if (this$1.token !== 1073741839 /* RightBrace */) {
            this$1.expect(context, 1073741842 /* Comma */);
        }
    }
    this.expect(context, 1073741839 /* RightBrace */);
};
// import <* as foo> ...;
Parser.prototype.parseImportNamespaceSpecifier = function parseImportNamespaceSpecifier (context, specifiers) {
    var pos = this.getLocation();
    this.expect(context | 1048576 /* ValidateEscape */, 67766835 /* Multiply */);
    if (this.token !== 69740 /* AsKeyword */)
        { this.report(85 /* NoAsAfterImportNamespace */); }
    this.expect(context, 69740 /* AsKeyword */);
    var local = this.parseBindingIdentifier(context);
    specifiers.push(this.finishNode(context, pos, {
        type: 'ImportNamespaceSpecifier',
        local: local
    }));
};
// import <foo> ...;
Parser.prototype.parseImportDefaultSpecifier = function parseImportDefaultSpecifier (context) {
    return this.finishNode(context, this.getLocation(), {
        type: 'ImportDefaultSpecifier',
        local: this.parseIdentifier(context)
    });
};
Parser.prototype.parseImportDeclaration = function parseImportDeclaration (context) {
    // ImportDeclaration :
    //   'import' ImportClause 'from' ModuleSpecifier ';'
    //   'import' ModuleSpecifier ';'
    //
    // ImportClause :
    //   ImportedDefaultBinding
    //   NameSpaceImport
    //   NamedImports
    //   ImportedDefaultBinding ',' NameSpaceImport
    //   ImportedDefaultBinding ',' NamedImports
    //
    // NameSpaceImport :
    //   '*' 'as' ImportedBinding
    var pos = this.getLocation();
    this.expect(context, 143450 /* ImportKeyword */);
    var source;
    // 'import' ModuleSpecifier ';'
    if (this.token === 131075 /* StringLiteral */) {
        source = this.parseLiteral(context);
        this.consumeSemicolon(context);
        return this.finishNode(context, pos, {
            type: 'ImportDeclaration',
            specifiers: [],
            source: source
        });
    }
    var specifiers = this.parseImportClause(context);
    source = this.parseModuleSpecifier(context);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ImportDeclaration',
        specifiers: specifiers,
        source: source
    });
};
Parser.prototype.parseImportClause = function parseImportClause (context) {
    var specifiers = [];
    switch (this.token) {
        case 16908289 /* Identifier */:
            {
                specifiers.push(this.parseImportDefaultSpecifier(context | 1048576 /* ValidateEscape */));
                if (this.consume(context, 1073741842 /* Comma */)) {
                    var t = this.token;
                    if (t & 67108864 /* IsGenerator */) {
                        this.parseImportNamespaceSpecifier(context, specifiers);
                    }
                    else if (t === 537001996 /* LeftBrace */) {
                        this.parseNamedImport(context, specifiers);
                    }
                    else {
                        this.report(1 /* UnexpectedToken */, tokenDesc(t));
                    }
                }
                break;
            }
        // import {bar}
        case 537001996 /* LeftBrace */:
            this.parseNamedImport(context | 1048576 /* ValidateEscape */, specifiers);
            break;
        // import * as foo
        case 67766835 /* Multiply */:
            this.parseImportNamespaceSpecifier(context, specifiers);
            break;
        default:
            this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(this.token));
    }
    return specifiers;
};
Parser.prototype.parseModuleItem = function parseModuleItem (context) {
    // ModuleItem :
    //ImportDeclaration
    //ExportDeclaration
    //StatementListItem
    switch (this.token) {
        // ExportDeclaration
        case 12371 /* ExportKeyword */:
            return this.parseExportDeclaration(context);
        // ImportDeclaration
        case 143450 /* ImportKeyword */:
            // 'Dynamic Import' or meta property disallowed here
            if (!(context & 1 /* OptionsNext */ && this.nextTokenIsLeftParenOrPeriod(context))) {
                return this.parseImportDeclaration(context);
            }
        default:
            return this.parseStatementListItem(context);
    }
};
// https://tc39.github.io/ecma262/#sec-statements
Parser.prototype.parseStatementListItem = function parseStatementListItem (context) {
    switch (this.token) {
        //   HoistableDeclaration[?Yield, ~Default]
        case 143448 /* FunctionKeyword */:
            return this.parseFunctionDeclaration(context);
        // ClassDeclaration[?Yield, ~Default]
        case 143437 /* ClassKeyword */:
            return this.parseClass(context & ~256 /* AllowIn */);
        // LexicalDeclaration[In, ?Yield]
        // LetOrConst BindingList[?In, ?Yield]
        case 151624 /* LetKeyword */:
            if (this.isLexical(context)) {
                return this.parseVariableStatement(context | 2097152 /* Let */ | 256 /* AllowIn */);
            }
            break;
        case 143433 /* ConstKeyword */:
            return this.parseVariableStatement(context | 256 /* AllowIn */ | 4194304 /* Const */);
        // ExportDeclaration and ImportDeclaration are only allowd inside modules and
        // forbidden here
        case 12371 /* ExportKeyword */:
            if (context & 1024 /* Module */)
                { this.tolerate(context, 69 /* ExportDeclAtTopLevel */); }
            break;
        case 143450 /* ImportKeyword */:
            // We must be careful not to parse a 'import()'
            // expression or 'import.meta' as an import declaration.
            if (context & 1 /* OptionsNext */ && this.nextTokenIsLeftParenOrPeriod(context)) {
                return this.parseExpressionStatement(context | 256 /* AllowIn */);
            }
            if (context & 1024 /* Module */)
                { this.tolerate(context, 70 /* ImportDeclAtTopLevel */); }
            break;
        default: // ignore
    }
    return this.parseStatement(context | 1073741824 /* AllowSingleStatement */);
};
// https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
Parser.prototype.parseStatement = function parseStatement (context) {
    switch (this.token) {
        // VariableStatement[?Yield]
        case 143431 /* VarKeyword */:
            return this.parseVariableStatement(context);
        // BlockStatement[?Yield, ?Return]
        case 537001996 /* LeftBrace */:
            return this.parseBlockStatement(context);
        case 1073872907 /* LeftParen */:
            return this.parseExpressionStatement(context | 256 /* AllowIn */);
        case 17 /* Semicolon */:
            return this.parseEmptyStatement(context);
        // [+Return] ReturnStatement[?Yield]
        case 12380 /* ReturnKeyword */:
            return this.parseReturnStatement(context);
        // IfStatement[?Yield, ?Return]
        case 12377 /* IfKeyword */:
            return this.parseIfStatement(context);
        // BreakableStatement[?Yield, ?Return]
        //
        // BreakableStatement[Yield, Return]:
        //   IterationStatement[?Yield, ?Return]
        //   SwitchStatement[?Yield, ?Return]
        case 12369 /* DoKeyword */:
            return this.parseDoWhileStatement(context);
        case 12386 /* WhileKeyword */:
            return this.parseWhileStatement(context);
        // WithStatement[?Yield, ?Return]
        case 12387 /* WithKeyword */:
            return this.parseWithStatement(context);
        case 143454 /* SwitchKeyword */:
            return this.parseSwitchStatement(context);
        case 12375 /* ForKeyword */:
            return this.parseForStatement(context);
        // BreakStatement[?Yield]
        case 12362 /* BreakKeyword */:
            return this.parseBreakStatement(context);
        // ContinueStatement[?Yield]
        case 12366 /* ContinueKeyword */:
            return this.parseContinueStatement(context);
        // EmptyStatement
        case 12367 /* DebuggerKeyword */:
            return this.parseDebuggerStatement(context);
        // ThrowStatement[?Yield]
        case 12384 /* ThrowKeyword */:
            return this.parseThrowStatement(context);
        // TryStatement[?Yield, ?Return]
        case 12385 /* TryKeyword */:
            return this.parseTryStatement(context);
        case 33624173 /* AsyncKeyword */:
            {
                if (this.nextTokenIsFuncKeywordOnSameLine(context)) {
                    if (context & 4096 /* AnnexB */ || !(context & 1073741824 /* AllowSingleStatement */)) {
                        this.tolerate(context, 68 /* AsyncFunctionInSingleStatementContext */);
                    }
                    // Async and async generator declaration is not allowed in statement position,
                    if (this.flags & 512 /* HasEscapedKeyword */)
                        { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
                    return this.parseFunctionDeclaration(context);
                }
                break;
            }
        case 143448 /* FunctionKeyword */:
            {
                this.report(context & 512 /* Strict */ ?
                    15 /* StrictFunction */ :
                    17 /* SloppyFunction */);
            }
        case 143437 /* ClassKeyword */:
            this.tolerate(context, 25 /* ForbiddenAsStatement */, tokenDesc(this.token));
        default:
    }
    return this.parseExpressionOrLabelledStatement(context);
};
// https://tc39.github.io/ecma262/#sec-labelled-statements
Parser.prototype.parseExpressionOrLabelledStatement = function parseExpressionOrLabelledStatement (context) {
    var pos = this.getLocation();
    var expr = this.parseExpression(context | 256 /* AllowIn */, pos);
    var t = this.token;
    if (t === 1073741845 /* Colon */ && expr.type === 'Identifier') {
        this.expect(context, 1073741845 /* Colon */);
        var key = '$' + expr.name;
        if (this.labelSet === undefined)
            { this.labelSet = {}; }
        else if (this.labelSet[key] === true) {
            this.tolerate(context, 46 /* Redeclaration */, expr.name);
        }
        this.labelSet[key] = true;
        t = this.token;
        var body;
        if (t === 12366 /* ContinueKeyword */ && this.flags & 4 /* AllowContinue */) {
            this.tolerate(context, 16 /* InvalidNestedStatement */, tokenDesc(t));
        }
        else if (!(context & 512 /* Strict */) && t === 143448 /* FunctionKeyword */ &&
            context & 1073741824 /* AllowSingleStatement */) {
            body = this.parseFunctionDeclaration(context | 4096 /* AnnexB */);
        }
        else {
            body = this.parseStatement(context | 4096 /* AnnexB */);
        }
        this.labelSet[key] = false;
        return this.finishNode(context, pos, {
            type: 'LabeledStatement',
            label: expr,
            body: body
        });
    }
    else {
        this.consumeSemicolon(context);
        return this.finishNode(context, pos, {
            type: 'ExpressionStatement',
            expression: expr
        });
    }
};
Parser.prototype.parseIfStatementChild = function parseIfStatementChild (context) {
    if (context & 512 /* Strict */ || this.token !== 143448 /* FunctionKeyword */) {
        return this.parseStatement(context & ~1073741824 /* AllowSingleStatement */ | 4096 /* AnnexB */);
    }
    return this.parseFunctionDeclaration(context | 4096 /* AnnexB */);
};
Parser.prototype.parseIfStatement = function parseIfStatement (context) {
    var pos = this.getLocation();
    if (this.flags & 512 /* HasEscapedKeyword */)
        { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
    this.expect(context, 12377 /* IfKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var test = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.expect(context, 16 /* RightParen */);
    var consequent = this.parseIfStatementChild(context | 1048576 /* ValidateEscape */);
    var alternate = null;
    if (this.consume(context, 12370 /* ElseKeyword */)) {
        alternate = this.parseIfStatementChild(context);
    }
    return this.finishNode(context, pos, {
        type: 'IfStatement',
        test: test,
        alternate: alternate,
        consequent: consequent
    });
};
// https://tc39.github.io/ecma262/#sec-while-statement
Parser.prototype.parseWhileStatement = function parseWhileStatement (context) {
    var pos = this.getLocation();
    this.expect(context, 12386 /* WhileKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var test = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.expect(context, 16 /* RightParen */);
    var savedFlag = this.flags;
    this.flags |= (4 /* AllowContinue */ | 8 /* AllowBreak */);
    var body = this.parseStatement(context & ~1073741824 /* AllowSingleStatement */ | 1048576 /* ValidateEscape */);
    this.flags = savedFlag;
    return this.finishNode(context, pos, {
        type: 'WhileStatement',
        test: test,
        body: body
    });
};
// https://tc39.github.io/ecma262/#sec-with-statement
Parser.prototype.parseWithStatement = function parseWithStatement (context) {
    if (context & 512 /* Strict */)
        { this.tolerate(context, 44 /* StrictModeWith */); }
    var pos = this.getLocation();
    this.expect(context, 12387 /* WithKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var object = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.expect(context, 16 /* RightParen */);
    var body = this.parseStatement(context & ~1073741824 /* AllowSingleStatement */ | 1048576 /* ValidateEscape */);
    return this.finishNode(context, pos, {
        type: 'WithStatement',
        object: object,
        body: body
    });
};
// https://tc39.github.io/ecma262/#sec-do-while-statement
Parser.prototype.parseDoWhileStatement = function parseDoWhileStatement (context) {
    var pos = this.getLocation();
    this.expect(context, 12369 /* DoKeyword */);
    var savedFlag = this.flags;
    this.flags |= (8 /* AllowBreak */ | 4 /* AllowContinue */);
    var body = this.parseStatement(context & ~1073741824 /* AllowSingleStatement */);
    this.flags = savedFlag;
    this.expect(context, 12386 /* WhileKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var test = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.expect(context, 16 /* RightParen */);
    this.consume(context, 17 /* Semicolon */);
    return this.finishNode(context, pos, {
        type: 'DoWhileStatement',
        body: body,
        test: test
    });
};
// https://tc39.github.io/ecma262/#sec-continue-statement
Parser.prototype.parseContinueStatement = function parseContinueStatement (context) {
    // Appearing of continue without an IterationStatement leads to syntax error
    if (!(this.flags & 4 /* AllowContinue */)) {
        this.tolerate(context, 16 /* InvalidNestedStatement */, tokenDesc(this.token));
    }
    var pos = this.getLocation();
    this.expect(context, 12366 /* ContinueKeyword */);
    var label = null;
    if (!(this.flags & 1 /* LineTerminator */) && this.isIdentifier(context, this.token)) {
        label = this.parseIdentifier(context);
        if (this.labelSet === undefined || !this.labelSet['$' + label.name]) {
            this.tolerate(context, 45 /* UnknownLabel */, label.name);
        }
    }
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ContinueStatement',
        label: label
    });
};
// https://tc39.github.io/ecma262/#sec-break-statement
Parser.prototype.parseBreakStatement = function parseBreakStatement (context) {
    var pos = this.getLocation();
    this.expect(context, 12362 /* BreakKeyword */);
    var label = null;
    if (!(this.flags & 1 /* LineTerminator */) && this.isIdentifier(context, this.token)) {
        label = this.parseIdentifier(context);
        if (this.labelSet === undefined || !this.labelSet['$' + label.name]) {
            this.tolerate(context, 45 /* UnknownLabel */, label.name);
        }
    }
    else if (!(this.flags & 8 /* AllowBreak */)) {
        this.tolerate(context, 16 /* InvalidNestedStatement */, 'break');
    }
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'BreakStatement',
        label: label
    });
};
// https://tc39.github.io/ecma262/#sec-throw-statement
Parser.prototype.parseThrowStatement = function parseThrowStatement (context) {
    var pos = this.getLocation();
    this.expect(context, 12384 /* ThrowKeyword */);
    if (this.flags & 1 /* LineTerminator */)
        { this.tolerate(context, 6 /* NewlineAfterThrow */); }
    var argument = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ThrowStatement',
        argument: argument
    });
};
Parser.prototype.parseTryStatement = function parseTryStatement (context) {
    if (this.flags & 512 /* HasEscapedKeyword */) {
        this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
    }
    var pos = this.getLocation();
    this.expect(context, 12385 /* TryKeyword */);
    var block = this.parseBlockStatement(context | 1048576 /* ValidateEscape */);
    if (this.token !== 12364 /* CatchKeyword */ && this.token !== 12374 /* FinallyKeyword */) {
        this.tolerate(context, 5 /* NoCatchOrFinally */);
    }
    var handler = this.token === 12364 /* CatchKeyword */ ?
        this.parseCatchBlock(context | 1048576 /* ValidateEscape */) :
        null;
    var finalizer = this.consume(context, 12374 /* FinallyKeyword */) ?
        this.parseBlockStatement(context) :
        null;
    return this.finishNode(context, pos, {
        type: 'TryStatement',
        block: block,
        handler: handler,
        finalizer: finalizer
    });
};
Parser.prototype.parseCatchBlock = function parseCatchBlock (context) {
    var pos = this.getLocation();
    this.expect(context, 12364 /* CatchKeyword */);
    var param = null;
    var hasBinding;
    if (context & 1 /* OptionsNext */) {
        hasBinding = this.consume(context, 1073872907 /* LeftParen */);
    }
    else {
        hasBinding = true;
        this.expect(context, 1073872907 /* LeftParen */);
    }
    if (hasBinding) {
        var params = [];
        param = this.parseBindingIdentifierOrBindingPattern(context, params);
        this.validateParams(context, params);
        this.expect(context, 16 /* RightParen */);
    }
    var body = this.parseBlockStatement(context);
    return this.finishNode(context, pos, {
        type: 'CatchClause',
        param: param,
        body: body
    });
};
Parser.prototype.parseSwitchStatement = function parseSwitchStatement (context) {
        var this$1 = this;

    var pos = this.getLocation();
    this.expect(context, 143454 /* SwitchKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var discriminant = this.parseExpression(context | 256 /* AllowIn */, pos);
    this.expect(context, 16 /* RightParen */);
    this.expect(context, 537001996 /* LeftBrace */);
    var cases = [];
    var SavedFlag = this.flags;
    this.flags |= 8 /* AllowBreak */;
    while (this.token !== 1073741839 /* RightBrace */) {
        cases.push(this$1.parseCaseOrDefaultClause(context));
    }
    this.flags = SavedFlag;
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'SwitchStatement',
        discriminant: discriminant,
        cases: cases
    });
};
// https://tc39.github.io/ecma262/#sec-switch-statement
Parser.prototype.parseCaseOrDefaultClause = function parseCaseOrDefaultClause (context) {
        var this$1 = this;

    var pos = this.getLocation();
    var test = this.consume(context, 12363 /* CaseKeyword */) ?
        this.parseExpression(context | 256 /* AllowIn */, pos) :
        null;
    var hasDefault = false;
    if (this.consume(context, 12368 /* DefaultKeyword */))
        { hasDefault = true; }
    this.expect(context, 1073741845 /* Colon */);
    var consequent = [];
    loop: while (true) {
        switch (this$1.token) {
            case 12368 /* DefaultKeyword */:
                if (hasDefault)
                    { this$1.tolerate(context, 86 /* MultipleDefaultsInSwitch */); }
            case 1073741839 /* RightBrace */:
            case 12363 /* CaseKeyword */:
                break loop;
            default:
                consequent.push(this$1.parseStatementListItem(context));
        }
    }
    return this.finishNode(context, pos, {
        type: 'SwitchCase',
        test: test,
        consequent: consequent,
    });
};
// https://tc39.github.io/ecma262/#sec-return-statement
Parser.prototype.parseReturnStatement = function parseReturnStatement (context) {
    if (!(this.flags & 16 /* InFunctionBody */))
        { this.tolerate(context, 59 /* IllegalReturn */); }
    var pos = this.getLocation();
    this.expect(context, 12380 /* ReturnKeyword */);
    var argument = null;
    if (!(this.flags & 1 /* LineTerminator */) && this.token !== 17 /* Semicolon */ &&
        this.token !== 1073741839 /* RightBrace */ && this.token !== 0 /* EndOfSource */) {
        argument = this.parseExpression(context | 256 /* AllowIn */, pos);
    }
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ReturnStatement',
        argument: argument
    });
};
// https://tc39.github.io/ecma262/#sec-debugger-statement
Parser.prototype.parseDebuggerStatement = function parseDebuggerStatement (context) {
    var pos = this.getLocation();
    if (this.flags & 512 /* HasEscapedKeyword */) {
        this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
    }
    this.expect(context, 12367 /* DebuggerKeyword */);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'DebuggerStatement'
    });
};
// https://tc39.github.io/ecma262/#sec-empty-statement
Parser.prototype.parseEmptyStatement = function parseEmptyStatement (context) {
    var pos = this.getLocation();
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'EmptyStatement'
    });
};
Parser.prototype.parseBlockStatement = function parseBlockStatement (context) {
        var this$1 = this;

    var pos = this.getLocation();
    var body = [];
    this.expect(context, 537001996 /* LeftBrace */);
    if (this.token !== 1073741839 /* RightBrace */) {
        while (this.token !== 1073741839 /* RightBrace */) {
            body.push(this$1.parseStatementListItem(context));
        }
    }
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'BlockStatement',
        body: body
    });
};
// https://tc39.github.io/ecma262/#sec-let-and-const-declarations
Parser.prototype.parseVariableStatement = function parseVariableStatement (context) {
    var pos = this.getLocation();
    var t = this.token;
    if (this.flags & 512 /* HasEscapedKeyword */)
        { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
    this.nextToken(context);
    var declarations = this.parseVariableDeclarationList(context);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'VariableDeclaration',
        declarations: declarations,
        kind: tokenDesc(t)
    });
};
Parser.prototype.parseVariableDeclarationList = function parseVariableDeclarationList (context) {
        var this$1 = this;

    var list = [this.parseVariableDeclaration(context)];
    if (this.token !== 1073741842 /* Comma */)
        { return list; }
    while (this.consume(context, 1073741842 /* Comma */)) {
        list.push(this$1.parseVariableDeclaration(context));
    }
    if (context & 16777216 /* ForStatement */ &&
        isInOrOfKeyword(this.token)) {
        if (list.length !== 1) {
            this.tolerate(context, 64 /* ForInOfLoopMultiBindings */, tokenDesc(this.token));
        }
    }
    return list;
};
Parser.prototype.parseVariableDeclaration = function parseVariableDeclaration (context) {
    var pos = this.getLocation();
    var t = this.token;
    var id = this.parseBindingIdentifierOrBindingPattern(context);
    var init = null;
    if (this.consume(context, 1074003997 /* Assign */)) {
        init = this.parseAssignmentExpression(context & ~(6291456 /* BlockScoped */ | 16777216 /* ForStatement */));
        if ((context & 16777216 /* ForStatement */ || t & 536870912 /* IsBindingPattern */) && isInOrOfKeyword(this.token)) {
            this.tolerate(context, 108 /* ForInOfLoopInitializer */, tokenDesc(this.token));
        }
        // Initializers are required for 'const' and binding patterns
    }
    else if ((context & 4194304 /* Const */ || t & 536870912 /* IsBindingPattern */) && !isInOrOfKeyword(this.token)) {
        this.report(48 /* DeclarationMissingInitializer */, context & 4194304 /* Const */ ? 'const' : 'destructuring');
    }
    return this.finishNode(context, pos, {
        type: 'VariableDeclarator',
        init: init,
        id: id
    });
};
// https://tc39.github.io/ecma262/#sec-expression-statement
Parser.prototype.parseExpressionStatement = function parseExpressionStatement (context) {
    var pos = this.getLocation();
    var expr = this.parseExpression(context, pos);
    this.consumeSemicolon(context);
    return this.finishNode(context, pos, {
        type: 'ExpressionStatement',
        expression: expr
    });
};
// https://tc39.github.io/ecma262/#sec-comma-operator
Parser.prototype.parseExpression = function parseExpression (context, pos) {
        var this$1 = this;

    var expr = this.parseAssignmentExpression(context);
    if (this.token !== 1073741842 /* Comma */)
        { return expr; }
    var expressions = [expr];
    while (this.consume(context, 1073741842 /* Comma */)) {
        expressions.push(this$1.parseAssignmentExpression(context));
    }
    return this.finishNode(context, pos, {
        type: 'SequenceExpression',
        expressions: expressions
    });
};
Parser.prototype.isIdentifier = function isIdentifier (context, t) {
    if (context & 512 /* Strict */) {
        if (t & 268435456 /* IsYield */)
            { return false; }
        return (t & 16777216 /* IsIdentifier */) === 16777216 /* IsIdentifier */ ||
            (t & 69632 /* Contextual */) === 69632 /* Contextual */;
    }
    return (t & 16777216 /* IsIdentifier */) === 16777216 /* IsIdentifier */ ||
        (t & 69632 /* Contextual */) === 69632 /* Contextual */ ||
        (t & 20480 /* FutureReserved */) === 20480 /* FutureReserved */;
};
// Reinterpret various expressions as pattern
// This Is only used for assignment and arrow parameter list
Parser.prototype.reinterpret = function reinterpret (context, node) {
        var this$1 = this;

    switch (node.type) {
        case 'ArrayPattern':
        case 'AssignmentPattern':
        case 'ObjectPattern':
        case 'RestElement':
        case 'MetaProperty':
        case 'Identifier':
            return; // skip
        case 'ObjectExpression':
            node.type = 'ObjectPattern';
            // ObjectPattern and ObjectExpression are isomorphic
            for (var i = 0; i < node.properties.length; i++) {
                this$1.reinterpret(context, node.properties[i]);
            }
            return;
        case 'ArrayExpression':
            node.type = 'ArrayPattern';
            for (var i$1 = 0; i$1 < node.elements.length; ++i$1) {
                // skip holes in pattern
                if (node.elements[i$1] !== null) {
                    this$1.reinterpret(context, node.elements[i$1]);
                }
            }
            return;
        case 'Property':
            if (node.kind !== 'init')
                { this.report(89 /* InvalidDestructuringTarget */); }
            return this.reinterpret(context, node.value);
        case 'SpreadElement':
            node.type = 'RestElement';
            this.reinterpret(context, node.argument);
            if (node.argument.type === 'AssignmentPattern')
                { this.tolerate(context, 41 /* InvalidRestDefaultValue */); }
            return;
        case 'AssignmentExpression':
            if (node.operator !== '=') {
                this.report(103 /* ComplexAssignment */);
            }
            else
                { delete node.operator; }
            node.type = 'AssignmentPattern';
            this.reinterpret(context, node.left);
            return;
        case 'MemberExpression':
            if (!(context & 16384 /* InParameter */))
                { return; }
        // Fall through
        default:
            this.report(context & 16384 /* InParameter */ ? 102 /* NotBindable */ : 101 /* NotAssignable */, node.type);
    }
};
Parser.prototype.parseYieldExpression = function parseYieldExpression (context, pos) {
    if (this.flags & 512 /* HasEscapedKeyword */) {
        this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
    }
    if (context & 16384 /* InParameter */) {
        this.tolerate(context, 53 /* InvalidGeneratorParam */);
    }
    this.expect(context, 268587115 /* YieldKeyword */);
    var argument = null;
    var delegate = false;
    if (!(this.flags & 1 /* LineTerminator */)) {
        delegate = this.consume(context, 67766835 /* Multiply */);
        argument = delegate ?
            this.parseAssignmentExpression(context) :
            this.token & 131072 /* IsExpressionStart */ ?
                this.parseAssignmentExpression(context) :
                null;
    }
    return this.finishNode(context, pos, {
        type: 'YieldExpression',
        argument: argument,
        delegate: delegate
    });
};
Parser.prototype.parseAssignmentExpression = function parseAssignmentExpression (context) {
    var pos = this.getLocation();
    var t = this.token;
    if (context & 32768 /* AllowYield */ && this.token & 268435456 /* IsYield */) {
        return this.parseYieldExpression(context, pos);
    }
    var expr = this.parseConditionalExpression(context, pos);
    if (this.token === 10 /* Arrow */ && (this.isIdentifier(context, t))) {
        if (t & 8388608 /* IsEvalArguments */) {
            if (context & 512 /* Strict */)
                { this.tolerate(context, 60 /* InvalidBindingStrictMode */, tokenDesc(t)); }
            this.errorLocation = this.getLocation();
            this.flags |= 8192 /* ReservedWords */;
        }
        return this.parseArrowFunctionExpression(context & ~65536 /* AllowAsync */, pos, [expr]);
    }
    if (!hasBit(this.token, 262144 /* IsAssignOp */))
        { return expr; }
    if (context & 512 /* Strict */ && this.isEvalOrArguments(expr.name)) {
        this.tolerate(context, 29 /* StrictLHSAssignment */);
        // Note: A functions parameter list is already parsed as pattern, so no need to reinterpret
    }
    if (!(context & 16384 /* InParameter */) && this.token === 1074003997 /* Assign */) {
        // Note: We don't know in cases like '((a = 0) => { "use strict"; })' if this is
        // an "normal" parenthese or an arrow function param list, so we set the "SimpleParameterList" flag
        // now. There is no danger in this because this will not throw unless we are parsing out an
        // function body.
        if (context & 33554432 /* InParenthesis */) {
            this.errorLocation = this.getLocation();
            this.flags |= 32 /* SimpleParameterList */;
        }
        this.reinterpret(context, expr);
    }
    else if (!isValidSimpleAssignmentTarget(expr)) {
        this.tolerate(context, 67 /* InvalidLHSInAssignment */);
    }
    var operator = this.token;
    this.nextToken(context);
    // Note! An arrow parameters must not contain yield expressions, but at this stage we doesn't know
    // if this is an "normal" parenthesis or inside and arrow param list, so we set
    // th "HasYield" flag now
    if (context & 32768 /* AllowYield */ && context & 33554432 /* InParenthesis */ && this.token & 268435456 /* IsYield */) {
        this.errorLocation = this.getLocation();
        this.flags |= 4096 /* HasYield */;
    }
    if (this.token & 134217728 /* IsAwait */) {
        this.errorLocation = this.getLocation();
        this.flags |= 2048 /* HasAwait */;
    }
    var right = this.parseAssignmentExpression(context | 256 /* AllowIn */);
    return this.finishNode(context, pos, {
        type: 'AssignmentExpression',
        left: expr,
        operator: tokenDesc(operator),
        right: right
    });
};
// https://tc39.github.io/ecma262/#sec-conditional-operator
Parser.prototype.parseConditionalExpression = function parseConditionalExpression (context, pos) {
    // ConditionalExpression ::
    // LogicalOrExpression
    // LogicalOrExpression '?' AssignmentExpression ':' AssignmentExpression
    var expr = this.parseBinaryExpression(context, 0, pos);
    if (!this.consume(context, 22 /* QuestionMark */))
        { return expr; }
    var consequent = this.parseAssignmentExpression(context | 256 /* AllowIn */);
    this.expect(context, 1073741845 /* Colon */);
    if (context & 67108864 /* InClass */ && this.token & 8388608 /* IsEvalArguments */) {
        this.tolerate(context, 94 /* ArgumentsDisallowedInInitializer */, tokenDesc(this.token));
    }
    var alternate = this.parseAssignmentExpression(context);
    return this.finishNode(context, pos, {
        type: 'ConditionalExpression',
        test: expr,
        consequent: consequent,
        alternate: alternate
    });
};
// https://tc39.github.io/ecma262/#sec-exp-operator
// https://tc39.github.io/ecma262/#sec-multiplicative-operators
// https://tc39.github.io/ecma262/#sec-additive-operators
// https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
// https://tc39.github.io/ecma262/#sec-relational-operators
// https://tc39.github.io/ecma262/#sec-equality-operators
// https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
// https://tc39.github.io/ecma262/#sec-binary-logical-operators
Parser.prototype.parseBinaryExpression = function parseBinaryExpression (context, minPrec, pos, expr) {
        var this$1 = this;
        if ( expr === void 0 ) expr = this.parseUnaryExpression(context);

    // Shift-reduce parser for the binary operator part of the JS expression
    // syntax.
    var bit = context & 256 /* AllowIn */ ^ 256 /* AllowIn */;
    while (hasBit(this.token, 655360 /* IsBinaryOp */)) {
        var t = this$1.token;
        if (bit && t === 669489 /* InKeyword */)
            { break; }
        var prec = t & 3840 /* Precedence */;
        var delta = (t === 658230 /* Exponentiate */) << 8 /* PrecStart */;
        // When the next token is no longer a binary operator, it's potentially the
        // start of an expression, so we bail out
        if (prec + delta <= minPrec)
            { break; }
        this$1.nextToken(context);
        expr = this$1.finishNode(context, pos, {
            type: t & 4194304 /* IsLogical */ ? 'LogicalExpression' : 'BinaryExpression',
            left: expr,
            right: this$1.parseBinaryExpression(context & ~256 /* AllowIn */, prec, this$1.getLocation()),
            operator: tokenDesc(t)
        });
    }
    return expr;
};
// https://tc39.github.io/ecma262/#sec-unary-operators
Parser.prototype.parseAwaitExpression = function parseAwaitExpression (context, pos) {
    if (this.flags & 512 /* HasEscapedKeyword */) {
        this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
    }
    // AwaitExpressionFormalParameter
    this.expect(context, 134418542 /* AwaitKeyword */);
    return this.finishNode(context, pos, {
        type: 'AwaitExpression',
        argument: this.parseUnaryExpression(context)
    });
};
Parser.prototype.parseUnaryExpression = function parseUnaryExpression (context) {
    // UnaryExpression ::
    //   PostfixExpression
    //   'delete' UnaryExpression
    //   'void' UnaryExpression
    //   'typeof' UnaryExpression
    //   '++' UnaryExpression
    //   '--' UnaryExpression
    //   '+' UnaryExpression
    //   '-' UnaryExpression
    //   '~' UnaryExpression
    //   '!' UnaryExpression
    //   [+Await] AwaitExpression[?Yield]
    var pos = this.getLocation();
    var t = this.token;
    if (hasBit(t, 1179648 /* IsUnaryOp */)) {
        t = this.token;
        if (this.flags & 512 /* HasEscapedKeyword */)
            { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
        this.nextToken(context);
        // The 'InClass' mask is only true if the 'optionsNext' is set in 'parseClass'
        if (context & 67108864 /* InClass */ && t === 1191978 /* TypeofKeyword */ && this.token & 8388608 /* IsEvalArguments */) {
            this.tolerate(context, 52 /* UnexpectedReservedWord */);
        }
        var argument = this.parseUnaryExpression(context);
        if (this.token === 658230 /* Exponentiate */)
            { this.reportUnexpectedTokenOrKeyword(); }
        if (context & 512 /* Strict */ && t === 1191979 /* DeleteKeyword */) {
            if (argument.type === 'Identifier') {
                this.tolerate(context, 28 /* StrictDelete */);
            }
            else if (isPropertyWithPrivateFieldKey(context, argument)) {
                this.tolerate(context, 109 /* DeletePrivateField */);
            }
        }
        return this.finishNode(context, pos, {
            type: 'UnaryExpression',
            operator: tokenDesc(t),
            argument: argument,
            prefix: true
        });
    }
    return (context & 65536 /* AllowAsync */ && t & 134217728 /* IsAwait */) ?
        this.parseAwaitExpression(context, pos) :
        this.parseUpdateExpression(context, pos);
};
Parser.prototype.isEvalOrArguments = function isEvalOrArguments (value) {
    return value === 'eval' || value === 'arguments';
};
// https://tc39.github.io/ecma262/#sec-update-expressions
Parser.prototype.parseUpdateExpression = function parseUpdateExpression (context, pos) {
    var prefix = false;
    var operator;
    if (hasBit(this.token, 2228224 /* IsUpdateOp */)) {
        operator = this.token;
        prefix = true;
        this.nextToken(context);
        if (context & 32768 /* AllowYield */ && this.token & 134217728 /* IsAwait */) {
            this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(this.token));
        }
    }
    else if (context & 64 /* OptionsJSX */ &&
        this.token === 657215 /* LessThan */ &&
        this.nextTokenIsIdentifierOrKeywordOrGreaterThan(context)) {
        return this.parseJSXElementOrFragment(context | 8192 /* Expression */);
    }
    var argument = this.parseLeftHandSideExpression(context, pos);
    var isPostfix = hasBit(this.token, 2228224 /* IsUpdateOp */) && !(this.flags & 1 /* LineTerminator */);
    if (!prefix && !isPostfix)
        { return argument; }
    if (context & 512 /* Strict */ &&
        this.isEvalOrArguments(argument.name)) {
        this.tolerate(context, 26 /* StrictLHSPrefixPostFix */, prefix ? 'Prefix' : 'Postfix');
    }
    else if (!isValidSimpleAssignmentTarget(argument)) {
        this.tolerate(context, 27 /* InvalidLhsInPrefixPostFixOp */, prefix ? 'Prefix' : 'Postfix');
    }
    if (!prefix) {
        operator = this.token;
        this.nextToken(context);
    }
    return this.finishNode(context, pos, {
        type: 'UpdateExpression',
        argument: argument,
        operator: tokenDesc(operator),
        prefix: prefix
    });
};
// https://tc39.github.io/ecma262/#prod-SuperProperty
Parser.prototype.parseSuperProperty = function parseSuperProperty (context) {
    var pos = this.getLocation();
    this.expect(context, 143453 /* SuperKeyword */);
    var t = this.token;
    if (t === 1073872907 /* LeftParen */) {
        // The super property has to be within a class constructor
        if (!(context & 524288 /* AllowSuperProperty */)) {
            this.tolerate(context, 56 /* BadSuperCall */);
        }
    }
    else if (t === 537002003 /* LeftBracket */ || t === 13 /* Period */) {
        if (!(context & 8388608 /* Method */)) {
            this.tolerate(context, 54 /* UnexpectedSuper */);
        }
    }
    else {
        this.tolerate(context, 55 /* LoneSuper */);
    }
    return this.finishNode(context, pos, {
        type: 'Super'
    });
};
Parser.prototype.parseImportExpressions = function parseImportExpressions (context, pos) {
    var id = this.parseIdentifier(context);
    // Import.meta - Stage 3 proposal
    if (context & 1 /* OptionsNext */ && this.consume(context | 1048576 /* ValidateEscape */, 13 /* Period */)) {
        if (context & 1024 /* Module */ && this.tokenValue === 'meta') {
            return this.parseMetaProperty(context, id, pos);
        }
        this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(this.token));
    }
    return this.finishNode(context, pos, {
        type: 'Import'
    });
};
Parser.prototype.parseMetaProperty = function parseMetaProperty (context, meta, pos) {
    return this.finishNode(context, pos, {
        meta: meta,
        type: 'MetaProperty',
        property: this.parseIdentifier(context)
    });
};
Parser.prototype.parseNewTargetExpression = function parseNewTargetExpression (context, t, name, pos) {
    // Note! We manually create a new identifier node her to speed up
    // 'new expression' parsing when location tracking is on. Here we
    // 're-use' the current 'pos' instead of calling it again inside
    // 'parseIdentifier'.
    var id = this.finishNode(context, pos, {
        type: 'Identifier',
        name: name
    });
    this.expect(context | 1048576 /* ValidateEscape */, 13 /* Period */);
    if (this.tokenValue !== 'target') {
        this.tolerate(context, 58 /* MetaNotInFunctionBody */);
    }
    else if (!(context & 16384 /* InParameter */)) {
        // An ArrowFunction in global code may not contain `new.target`
        if (context & 131072 /* ArrowFunction */ && context & 262144 /* TopLevel */) {
            this.tolerate(context, 57 /* NewTargetArrow */);
        }
        if (!(this.flags & 16 /* InFunctionBody */)) {
            this.tolerate(context, 58 /* MetaNotInFunctionBody */);
        }
    }
    return this.parseMetaProperty(context, id, pos);
};
Parser.prototype.parseNewExpression = function parseNewExpression (context) {
    if (this.flags & 512 /* HasEscapedKeyword */) {
        this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
    }
    var pos = this.getLocation();
    var t = this.token;
    var tokenValue = this.tokenValue;
    this.expect(context, 143451 /* NewKeyword */);
    if (this.token === 13 /* Period */) {
        return this.parseNewTargetExpression(context, t, tokenValue, pos);
    }
    return this.finishNode(context, pos, {
        type: 'NewExpression',
        callee: this.parseMemberExpression(context | 268435456 /* DisallowArrow */, pos),
        arguments: this.token === 1073872907 /* LeftParen */ ? this.parseArgumentList(context) : []
    });
};
Parser.prototype.parseLeftHandSideExpression = function parseLeftHandSideExpression (context, pos) {
    var expr = this.parseMemberExpression(context | 256 /* AllowIn */, pos);
    return expr.type === 'ArrowFunctionExpression' && this.token !== 1073872907 /* LeftParen */ ?
        expr :
        this.parseCallExpression(context | 256 /* AllowIn */, pos, expr);
};
Parser.prototype.parseIdentifierNameOrPrivateName = function parseIdentifierNameOrPrivateName (context) {
    if (!this.consume(context, 118 /* Hash */))
        { return this.parseIdentifierName(context, this.token); }
    if (!(this.token & 16777216 /* IsIdentifier */))
        { this.report(0 /* Unexpected */); }
    var pos = this.getLocation();
    var name = this.tokenValue;
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'PrivateName',
        name: name
    });
};
Parser.prototype.parseMemberExpression = function parseMemberExpression (context, pos, expr) {
        var this$1 = this;
        if ( expr === void 0 ) expr = this.parsePrimaryExpression(context, pos);

    while (true) {
        switch (this$1.token) {
            case 13 /* Period */:
                {
                    this$1.expect(context, 13 /* Period */);
                    var property = this$1.parseIdentifierNameOrPrivateName(context);
                    expr = this$1.finishNode(context, pos, {
                        type: 'MemberExpression',
                        object: expr,
                        computed: false,
                        property: property,
                    });
                    break;
                }
            case 537002003 /* LeftBracket */:
                {
                    this$1.expect(context, 537002003 /* LeftBracket */);
                    var property$1 = this$1.parseExpression(context, this$1.getLocation());
                    this$1.expect(context, 20 /* RightBracket */);
                    expr = this$1.finishNode(context, pos, {
                        type: 'MemberExpression',
                        object: expr,
                        computed: true,
                        property: property$1,
                    });
                    break;
                }
            case 131080 /* TemplateCont */:
            case 131081 /* TemplateTail */:
                {
                    var quasi = this$1.token === 131081 /* TemplateTail */ ?
                        this$1.parseTemplateLiteral(context) : this$1.parseTemplate(context | 2048 /* TaggedTemplate */);
                    expr = this$1.finishNode(context, pos, {
                        type: 'TaggedTemplateExpression',
                        tag: expr,
                        quasi: quasi
                    });
                    break;
                }
            default:
                return expr;
        }
    }
};
Parser.prototype.parseTemplateLiteral = function parseTemplateLiteral (context) {
    var pos = this.getLocation();
    return this.finishNode(context, pos, {
        type: 'TemplateLiteral',
        expressions: [],
        quasis: [this.parseTemplateSpans(context)]
    });
};
Parser.prototype.parseTemplateHead = function parseTemplateHead (context, cooked, raw, pos) {
        if ( cooked === void 0 ) cooked = null;

    this.token = this.consumeTemplateBrace(context);
    return this.finishNode(context, pos, {
        type: 'TemplateElement',
        value: {
            cooked: cooked,
            raw: raw
        },
        tail: false
    });
};
Parser.prototype.parseTemplate = function parseTemplate (context, expressions, quasis) {
        if ( expressions === void 0 ) expressions = [];
        if ( quasis === void 0 ) quasis = [];

    var pos = this.getLocation();
    var cooked = this.tokenValue;
    var raw = this.tokenRaw;
    this.expect(context, 131080 /* TemplateCont */);
    expressions.push(this.parseExpression(context, pos));
    var t = this.getLocation();
    quasis.push(this.parseTemplateHead(context, cooked, raw, pos));
    if (this.token === 131081 /* TemplateTail */) {
        quasis.push(this.parseTemplateSpans(context, t));
    }
    else {
        this.parseTemplate(context, expressions, quasis);
    }
    return this.finishNode(context, pos, {
        type: 'TemplateLiteral',
        expressions: expressions,
        quasis: quasis
    });
};
// Parse template spans
Parser.prototype.parseTemplateSpans = function parseTemplateSpans (context, pos) {
        if ( pos === void 0 ) pos = this.getLocation();

    var cooked = this.tokenValue;
    var raw = this.tokenRaw;
    this.expect(context, 131081 /* TemplateTail */);
    return this.finishNode(context, pos, {
        type: 'TemplateElement',
        value: {
            cooked: cooked,
            raw: raw
        },
        tail: true
    });
};
// https://tc39.github.io/ecma262/#prod-CallExpression
Parser.prototype.parseCallExpression = function parseCallExpression (context, pos, expr) {
        var this$1 = this;

    while (true) {
        expr = this$1.parseMemberExpression(context, pos, expr);
        if (this$1.token !== 1073872907 /* LeftParen */)
            { return expr; }
        var args = this$1.parseArgumentList(context);
        if (context & 1 /* OptionsNext */ && expr.type === 'Import' &&
            args.length !== 1 &&
            expr.type === 'Import') {
            this$1.tolerate(context, 93 /* BadImportCallArity */);
        }
        expr = this$1.finishNode(context, pos, {
            type: 'CallExpression',
            callee: expr,
            arguments: args
        });
    }
};
// https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
Parser.prototype.parseArgumentList = function parseArgumentList (context) {
        var this$1 = this;

    this.expect(context, 1073872907 /* LeftParen */);
    var expressions = [];
    while (this.token !== 16 /* RightParen */) {
        if (this$1.token === 14 /* Ellipsis */) {
            expressions.push(this$1.parseSpreadElement(context));
        }
        else {
            expressions.push(this$1.parseAssignmentExpression(context | 256 /* AllowIn */));
        }
        if (this$1.token === 16 /* RightParen */)
            { break; }
        if (context & 32 /* OptionsTolerate */) {
            this$1.nextToken(context);
            this$1.tolerate(context, 1 /* UnexpectedToken */, ',');
        }
        else {
            this$1.expect(context, 1073741842 /* Comma */);
        }
        if (this$1.token === 16 /* RightParen */)
            { break; }
    }
    this.expect(context, 16 /* RightParen */);
    if (this.token === 10 /* Arrow */) {
        this.report(1 /* UnexpectedToken */, tokenDesc(this.token));
    }
    return expressions;
};
// https://tc39.github.io/ecma262/#prod-SpreadElement
Parser.prototype.parseSpreadElement = function parseSpreadElement (context) {
    var pos = this.getLocation();
    var t = this.token;
    this.expect(context, 14 /* Ellipsis */);
    var arg = this.parseAssignmentExpression(context | 256 /* AllowIn */);
    return this.finishNode(context, pos, {
        type: 'SpreadElement',
        argument: arg
    });
};
Parser.prototype.parseAndClassifyIdentifier = function parseAndClassifyIdentifier (context) {
    var t = this.token;
    if (context & 512 /* Strict */) {
        // Module code is also "strict mode code"
        if (context & 1024 /* Module */ && t & 134217728 /* IsAwait */) {
            this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
        }
        if (t & 268435456 /* IsYield */)
            { this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t)); }
        if ((t & 16777216 /* IsIdentifier */) === 16777216 /* IsIdentifier */ ||
            (t & 69632 /* Contextual */) === 69632 /* Contextual */) {
            return this.parseIdentifier(context);
        }
        this.reportUnexpectedTokenOrKeyword();
    }
    if (context & 32768 /* AllowYield */ && t & 268435456 /* IsYield */) {
        this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
    }
    if ((t & 16777216 /* IsIdentifier */) === 16777216 /* IsIdentifier */ ||
        (t & 69632 /* Contextual */) === 69632 /* Contextual */ ||
        (t & 20480 /* FutureReserved */) === 20480 /* FutureReserved */) {
        return this.parseIdentifier(context);
    }
    this.reportUnexpectedTokenOrKeyword();
};
// https://tc39.github.io/ecma262/#sec-primary-expression
Parser.prototype.parsePrimaryExpression = function parsePrimaryExpression (context, pos) {
    switch (this.token) {
        case 16908289 /* Identifier */:
            return this.parseIdentifier(context);
        case 131074 /* NumericLiteral */:
        case 131075 /* StringLiteral */:
            return this.parseLiteral(context);
        case 143367 /* NullKeyword */:
        case 143366 /* TrueKeyword */:
        case 143365 /* FalseKeyword */:
            return this.parseNullOrTrueOrFalseExpression(context, pos);
        case 143455 /* ThisKeyword */:
            return this.parseThisExpression(context);
        case 120 /* BigInt */:
            return this.parseBigIntLiteral(context, pos);
        case 1073872907 /* LeftParen */:
            return this.parseExpressionCoverGrammar(context | 256 /* AllowIn */ | 33554432 /* InParenthesis */);
        case 537002003 /* LeftBracket */:
            return this.parseArrayLiteral(context);
        case 537001996 /* LeftBrace */:
            return this.parseObjectLiteral(context & ~(524288 /* AllowSuperProperty */ | 67108864 /* InClass */));
        case 143453 /* SuperKeyword */:
            return this.parseSuperProperty(context);
        case 143437 /* ClassKeyword */:
            return this.parseClass(context & ~256 /* AllowIn */ | 8192 /* Expression */);
        case 143448 /* FunctionKeyword */:
            return this.parseFunctionExpression(context & ~32768 /* AllowYield */ | 8192 /* Expression */);
        case 143451 /* NewKeyword */:
            return this.parseNewExpression(context);
        case 131081 /* TemplateTail */:
            return this.parseTemplateLiteral(context);
        case 131080 /* TemplateCont */:
            return this.parseTemplate(context);
        case 143450 /* ImportKeyword */:
            if (!(context & 1 /* OptionsNext */))
                { this.tolerate(context, 0 /* Unexpected */); }
            return this.parseImportExpressions(context | 256 /* AllowIn */, pos);
        case 657973 /* Divide */:
        case 393253 /* DivideAssign */:
            {
                if (this.scanRegularExpression(context) === 131076 /* RegularExpression */) {
                    return this.parseRegularExpressionLiteral(context);
                }
                this.report(72 /* UnterminatedRegExp */);
            }
        case 33624173 /* AsyncKeyword */:
            return this.parseAsyncFunctionExpression(context, pos);
        case 151624 /* LetKeyword */:
            {
                // 'let' must not be in expression position in strict mode
                if (context & 512 /* Strict */) {
                    this.tolerate(context, 51 /* InvalidStrictExpPostion */, 'let');
                }
                var name = this.tokenValue;
                this.nextToken(context);
                this.errorLocation = pos;
                // ExpressionStatement has a lookahead restriction for `let [`.
                if (this.flags & 1 /* LineTerminator */) {
                    if (this.token === 537002003 /* LeftBracket */) {
                        this.tolerate(context, 1 /* UnexpectedToken */, 'let');
                    }
                }
                else if (!(context & 1073741824 /* AllowSingleStatement */)) {
                    this.tolerate(context, 114 /* UnexpectedLexicalDeclaration */);
                }
                return this.finishNode(context, pos, {
                    type: 'Identifier',
                    name: name
                });
            }
        case 118 /* Hash */:
            return this.parseIdentifierNameOrPrivateName(context);
        default:
            return this.parseAndClassifyIdentifier(context);
    }
};
// http://www.ecma-international.org/ecma-262/8.0/#prod-AsyncFunctionExpression
Parser.prototype.parseAsyncFunctionExpression = function parseAsyncFunctionExpression (context, pos) {
        var this$1 = this;

    var hasEscape = (this.flags & 512 /* HasEscapedKeyword */) !== 0;
    var flags = this.flags;
    var id = this.parseIdentifier(context);
    if (this.flags & 1 /* LineTerminator */)
        { return id; }
    // To avoid a look-ahead, we simply set the 'AsyncFunction' bit after
    // consuming the 'async' token before parsing out the 'FunctionExpression' itself.
    if (this.token === 143448 /* FunctionKeyword */) {
        if (hasEscape)
            { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
        return this.parseFunctionExpression(context & ~4096 /* AnnexB */ | (8192 /* Expression */ | 65536 /* AllowAsync */), true, pos);
    }
    var t = this.token;
    // Check if we this is a "concise body" async arrow function followed by either
    // an identifer or 'yield'
    if (t & (16777216 /* IsIdentifier */ | 268435456 /* IsYield */)) {
        if (hasEscape)
            { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
        // If we have a LineTerminator here, it can't be an arrow functions. So simply
        // return the identifer.
        if (this.flags & 1 /* LineTerminator */)
            { return id; }
        // The yield keyword may not be used in an arrow function's body (except when permitted
        // within functions further nested within it). As a consequence, arrow functions
        // cannot be used as generators.
        if (context & 32768 /* AllowYield */ && t & 268435456 /* IsYield */) {
            this.tolerate(context, 0 /* Unexpected */);
        }
        var expr = this.parseIdentifier(context);
        if (this.token !== 10 /* Arrow */)
            { this.tolerate(context, 0 /* Unexpected */); }
        return this.parseArrowFunctionExpression(context | 65536 /* AllowAsync */, pos, [expr]);
    }
    // A plain async identifier - 'async'. Nothing more we can do, so return.
    if (this.token !== 1073872907 /* LeftParen */)
        { return id; }
    var params = [];
    var state = 0 /* None */;
    var args = [];
    // http://www.ecma-international.org/ecma-262/8.0/#prod-CoverCallExpressionAndAsyncArrowHead
    this.expect(context, 1073872907 /* LeftParen */);
    // 'async (' can be the start of an async arrow function or a call expression...
    while (this.token !== 16 /* RightParen */) {
        if (this$1.token === 14 /* Ellipsis */) {
            var elem = this$1.parseSpreadElement(context);
            // Trailing comma in async arrow param list
            if (this$1.token === 1073741842 /* Comma */)
                { state |= 64 /* Trailing */; }
            args.push(elem);
            break;
        }
        // Start of a binding pattern inside parenthesis - '({foo: bar})', '{[()]}'
        if (hasBit(this$1.token, 536870912 /* IsBindingPattern */)) {
            this$1.errorLocation = this$1.getLocation();
            state |= 2 /* BindingPattern */;
        }
        if (hasBit(this$1.token, 8388608 /* IsEvalArguments */)) {
            this$1.errorLocation = this$1.getLocation();
            state |= 8 /* EvalOrArguments */;
        }
        if (hasBit(this$1.token, 268435456 /* IsYield */)) {
            this$1.errorLocation = this$1.getLocation();
            state |= 32 /* Yield */;
        }
        // The parenthesis contain a future reserved word. Flag it and throw
        // later on if it turns out that we are in a strict mode context
        if (hasBit(this$1.token, 20480 /* FutureReserved */)) {
            this$1.errorLocation = this$1.getLocation();
            state |= 4 /* FutureReserved */;
        }
        if (hasBit(this$1.token, 134217728 /* IsAwait */)) {
            this$1.errorLocation = this$1.getLocation();
            state |= 16 /* Await */;
            this$1.flags |= 2048 /* HasAwait */;
        }
        // Maybe nested parenthesis - ((foo))
        if (this$1.token === 1073872907 /* LeftParen */) {
            this$1.errorLocation = this$1.getLocation();
            state |= 1 /* NestedParenthesis */;
        }
        args.push(this$1.parseAssignmentExpression(context | 33554432 /* InParenthesis */));
        this$1.consume(context, 1073741842 /* Comma */);
    }
    this.expect(context, 16 /* RightParen */);
    if (this.token === 10 /* Arrow */) {
        if (hasEscape)
            { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
        // async ( Arguments ) => ...
        if (args.length > 0) {
            if (state & 2 /* BindingPattern */) {
                this.flags |= 32 /* SimpleParameterList */;
            }
            // A async arrows cannot have a line terminator between "async" and the formals
            if (flags & 1 /* LineTerminator */) {
                this.tolerate(context, 11 /* LineBreakAfterAsync */);
            }
            if (state & 32 /* Yield */) {
                this.tolerate(context, 61 /* InvalidAwaitInArrowParam */);
            }
            if (this.flags & 2048 /* HasAwait */) {
                this.tolerate(context, 61 /* InvalidAwaitInArrowParam */);
            }
            if (state & 8 /* EvalOrArguments */) {
                // Invalid: '"use strict"; (eval = 10) => 42;'
                if (context & 512 /* Strict */)
                    { this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */); }
                // Invalid: 'async (eval = 10) => { "use strict"; }'
                // this.errorLocation = this.getLocation();
                this.flags |= 8192 /* ReservedWords */;
            }
            if (state & 1 /* NestedParenthesis */) {
                this.tolerate(context, 13 /* InvalidParenthesizedPattern */);
            }
            if (state & 64 /* Trailing */) {
                this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(this.token));
            }
            // Invalid: 'async (package) => { "use strict"; }'
            if (state & 4 /* FutureReserved */) {
                this.errorLocation = this.getLocation();
                this.flags |= 8192 /* ReservedWords */;
            }
        }
        return this.parseArrowFunctionExpression(context | 65536 /* AllowAsync */, pos, args, params);
    }
    return this.finishNode(context, pos, {
        type: 'CallExpression',
        callee: id,
        arguments: args
    });
};
Parser.prototype.parseObjectLiteral = function parseObjectLiteral (context) {
        var this$1 = this;

    var pos = this.getLocation();
    this.expect(context, 537001996 /* LeftBrace */);
    var properties = [];
    // Checking for the 'RightBrace' token here avoid the "bit toggling"
    // in cases where the object body is empty. E.g. '({})'
    if (this.token !== 1073741839 /* RightBrace */) {
        while (this.token !== 1073741839 /* RightBrace */) {
            properties.push(this$1.token === 14 /* Ellipsis */ ?
                this$1.parseSpreadElement(context) :
                this$1.parsePropertyDefinition(context));
            if (this$1.token !== 1073741839 /* RightBrace */)
                { this$1.expect(context, 1073741842 /* Comma */); }
        }
        if (this.flags & 256 /* DuplicateProtoField */ && this.token !== 1074003997 /* Assign */) {
            this.tolerate(context, 19 /* DuplicateProtoProperty */);
        }
        // Unset the 'HasProtoField' flag now, we are done!
        this.flags &= ~(128 /* ProtoField */ | 256 /* DuplicateProtoField */);
    }
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'ObjectExpression',
        properties: properties
    });
};
// http://www.ecma-international.org/ecma-262/8.0/#prod-PropertyDefinition
Parser.prototype.parsePropertyDefinition = function parsePropertyDefinition (context) {
    var pos = this.getLocation();
    var t = this.token;
    var state = 0 /* None */;
    var value = null;
    var key = null;
    var isEscaped = (this.flags & 512 /* HasEscapedKeyword */) !== 0;
    if (this.consume(context, 67766835 /* Multiply */))
        { state |= 16 /* Generator */; }
    if (this.token & 33554432 /* IsAsync */ && !(state & 16 /* Generator */)) {
        var isIdentifier = this.parseIdentifier(context);
        if (this.token & 1073741824 /* IsShorthand */) {
            key = isIdentifier;
        }
        else {
            if (this.flags & 1 /* LineTerminator */) {
                this.tolerate(context, 11 /* LineBreakAfterAsync */);
            }
            // Invalid: '({ \\u0061sync* m(){} });'
            if (isEscaped) {
                this.tolerate(context, 36 /* UnexpectedEscapedKeyword */);
            }
            state |= this.consume(context, 67766835 /* Multiply */) ?
                state |= 32 /* Async */ | 16 /* Generator */ :
                32 /* Async */;
            t = this.token;
            if (t === 537002003 /* LeftBracket */) {
                state |= 2 /* Computed */;
            }
            key = this.parsePropertyName(context);
        }
    }
    else {
        if (this.token === 537002003 /* LeftBracket */)
            { state |= 2 /* Computed */; }
        key = this.parsePropertyName(context);
    }
    if (!(state & 2 /* Computed */) &&
        this.token !== 1073872907 /* LeftParen */ &&
        (t === 69744 /* GetKeyword */ || t === 69745 /* SetKeyword */) &&
        this.token !== 1073741845 /* Colon */ && this.token !== 1073741839 /* RightBrace */) {
        if (state & (16 /* Generator */ | 32 /* Async */)) {
            this.tolerate(context, 0 /* Unexpected */);
        }
        if (isEscaped)
            { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
        if (t === 69744 /* GetKeyword */)
            { state |= 8 /* Get */; }
        else
            { state |= 4 /* Set */; }
        key = this.parsePropertyName(context);
        value = this.parseMethodDeclaration(context & ~(524288 /* AllowSuperProperty */ | 65536 /* AllowAsync */ | 32768 /* AllowYield */), state);
    }
    else {
        switch (this.token) {
            case 1073872907 /* LeftParen */:
                {
                    // If not 'get' or 'set', it has to be a 'method'
                    if (!(state & 12 /* Accessors */)) {
                        state |= 128 /* Method */;
                    }
                    value = this.parseMethodDeclaration(context & ~(256 /* AllowIn */ | 65536 /* AllowAsync */ | 32768 /* AllowYield */), state);
                    break;
                }
            case 1073741845 /* Colon */:
                {
                    if (this.tokenValue === '__proto__')
                        { state |= 512 /* Prototype */; }
                    this.expect(context, 1073741845 /* Colon */);
                    if (context & 512 /* Strict */ && this.token & 8388608 /* IsEvalArguments */) {
                        this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */);
                    }
                    if (state & 512 /* Prototype */ && !(state & 2 /* Computed */)) {
                        // Annex B defines an tolerate error for duplicate PropertyName of `__proto__`,
                        // in object initializers, but this does not apply to Object Assignment
                        // patterns, so we need to validate this *after* done parsing
                        // the object expression
                        this.flags |= this.flags & 128 /* ProtoField */ ?
                            256 /* DuplicateProtoField */ :
                            128 /* ProtoField */;
                    }
                    if (this.token & 134217728 /* IsAwait */) {
                        this.errorLocation = this.getLocation();
                        this.flags |= 2048 /* HasAwait */;
                    }
                    if (state & (16 /* Generator */ | 32 /* Async */)) {
                        this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
                    }
                    value = this.parseAssignmentExpression(context);
                    break;
                }
            default:
                if (state & 32 /* Async */ || !this.isIdentifier(context, t)) {
                    this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(t));
                }
                if (context & 32768 /* AllowYield */ &&
                    t & 268435456 /* IsYield */) {
                    this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
                }
                else if (t & (134217728 /* IsAwait */)) {
                    if (context & 65536 /* AllowAsync */)
                        { this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t)); }
                    this.errorLocation = this.getLocation();
                    this.flags |= 2048 /* HasAwait */;
                }
                if (context & 512 /* Strict */ && t & 8388608 /* IsEvalArguments */) {
                    this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */);
                }
                state |= 256 /* Shorthand */;
                value = this.parseAssignmentPattern(context, [], pos, key);
        }
    }
    return this.finishNode(context, pos, {
        type: 'Property',
        key: key,
        value: value,
        kind: !(state & 12 /* Accessors */) ? 'init' : (state & 4 /* Set */) ? 'set' : 'get',
        computed: !!(state & 2 /* Computed */),
        method: !!(state & 128 /* Method */),
        shorthand: !!(state & 256 /* Shorthand */)
    });
};
Parser.prototype.parseMethodDeclaration = function parseMethodDeclaration (context, state) {
    var pos = this.getLocation();
    if (state & 16 /* Generator */)
        { context |= 32768 /* AllowYield */; }
    if (state & 32 /* Async */)
        { context |= 65536 /* AllowAsync */; }
    return this.parseFunction(context & ~262144 /* TopLevel */ | 8192 /* Expression */ | 8388608 /* Method */, null, pos, state);
};
Parser.prototype.parseComputedPropertyName = function parseComputedPropertyName (context) {
    var pos = this.getLocation();
    this.expect(context, 537002003 /* LeftBracket */);
    var expression = this.parseAssignmentExpression(context | 256 /* AllowIn */);
    this.expect(context, 20 /* RightBracket */);
    return expression;
};
Parser.prototype.parsePropertyName = function parsePropertyName (context, state /* None */) {
        if ( state === void 0 ) state = 0;

    var pos = this.getLocation();
    switch (this.token) {
        case 131074 /* NumericLiteral */:
        case 131075 /* StringLiteral */:
            return this.parseLiteral(context);
        case 537002003 /* LeftBracket */:
            return this.parseComputedPropertyName(context);
        default:
            return this.parseIdentifier(context);
    }
};
Parser.prototype.parseArrayLiteral = function parseArrayLiteral (context) {
        var this$1 = this;

    var pos = this.getLocation();
    this.expect(context, 537002003 /* LeftBracket */);
    var elements = [];
    var state = 0 /* None */;
    while (this.token !== 20 /* RightBracket */) {
        if (this$1.consume(context, 1073741842 /* Comma */)) {
            elements.push(null);
        }
        else if (this$1.token === 14 /* Ellipsis */) {
            var element = this$1.parseSpreadElement(context);
            // Note! An AssignmentElement may not follow an
            // AssignmentRestElement - e.g. '[...x, y] = [];' - but we don't know
            // yet if this array are followed by an initalizer or not.
            // That is something we will find out after we have swallowed the ']' token.
            // So for now, we mark the comma as found, and continue parsing...
            if (this$1.token === 1073741842 /* Comma */) {
                state |= 1 /* CommaSeparator */;
            }
            if (this$1.token !== 20 /* RightBracket */)
                { this$1.expect(context, 1073741842 /* Comma */); }
            elements.push(element);
        }
        else {
            // Note! In case we are parsing out a arrow param list, we
            // mark the 'await' keyword here if found. This cover cases
            // like: '"use strict" ([await]) => {}'
            if (this$1.token & 134217728 /* IsAwait */) {
                this$1.errorLocation = this$1.getLocation();
                this$1.flags |= 2048 /* HasAwait */;
            }
            if (this$1.token & 8388608 /* IsEvalArguments */) {
                this$1.errorLocation = this$1.getLocation();
                state |= 2 /* EvalOrArguments */;
            }
            elements.push(this$1.parseAssignmentExpression(context | 256 /* AllowIn */));
            if (this$1.token !== 20 /* RightBracket */)
                { this$1.expect(context, 1073741842 /* Comma */); }
        }
    }
    this.expect(context, 20 /* RightBracket */);
    if (state & 1 /* CommaSeparator */) {
        // We got a comma separator and we have a initializer. Time to throw an error!
        if (this.token === 1074003997 /* Assign */)
            { this.tolerate(context, 42 /* ElementAfterRest */); }
        // Note! This also affects arrow expressions because we are parsing out the
        // arrow param list either in 'parseExpressionCoverGrammar' or
        // 'parseAsyncFunctionExpression'. So in that case we 'flag' that
        // we found something we don't like, and throw later on.
        //
        // E.g. 'f = ([...[x], y]) => {}'
        //
        this.flags |= 16384 /* HasCommaSeparator */;
    }
    else if (state & 2 /* EvalOrArguments */) {
        if (context & 16777216 /* ForStatement */) {
            if (context & 512 /* Strict */)
                { this.tolerate(context, 52 /* UnexpectedReservedWord */); }
        }
        else if (this.token === 1074003997 /* Assign */) {
            this.tolerate(context, 52 /* UnexpectedReservedWord */);
        }
    }
    return this.finishNode(context, pos, {
        type: 'ArrayExpression',
        elements: elements
    });
};
// https://tc39.github.io/ecma262/#prod-ClassDeclaration
// https://tc39.github.io/ecma262/#prod-ClassExpression
Parser.prototype.parseClass = function parseClass (context) {
    if (this.flags & 512 /* HasEscapedKeyword */)
        { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
    var pos = this.getLocation();
    this.expect(context, 143437 /* ClassKeyword */);
    var state = 0 /* None */;
    var t = this.token;
    var id = null;
    var superClass = null;
    if (this.token !== 537001996 /* LeftBrace */ && this.token !== 12373 /* ExtendsKeyword */) {
        id = this.parseBindingIdentifier(context);
    }
    else if (!(context & 8192 /* Expression */) && !(context & 134217728 /* RequireIdentifier */)) {
        this.tolerate(context, 1 /* UnexpectedToken */, tokenDesc(t));
    }
    if (this.consume(context, 12373 /* ExtendsKeyword */)) {
        superClass = this.parseLeftHandSideExpression(context | 512 /* Strict */, pos);
        state |= 1024 /* Heritage */;
    }
    return this.finishNode(context, pos, {
        type: context & 8192 /* Expression */ ? 'ClassExpression' : 'ClassDeclaration',
        id: id,
        superClass: superClass,
        body: this.parseClassElementList(context | 512 /* Strict */ | 1048576 /* ValidateEscape */, state)
    });
};
Parser.prototype.parseClassElementList = function parseClassElementList (context, state) {
        var this$1 = this;

    var pos = this.getLocation();
    // Stage 3 - Class fields
    if (context & 1 /* OptionsNext */) {
        context |= 67108864 /* InClass */;
    }
    this.expect(context | 1048576 /* ValidateEscape */, 537001996 /* LeftBrace */);
    var body = [];
    while (this.token !== 1073741839 /* RightBrace */) {
        if (!this$1.consume(context, 17 /* Semicolon */)) {
            var node = this$1.parseClassElement(context, state);
            body.push(node);
            if (node.kind === 'constructor')
                { state |= 2048 /* HasConstructor */; }
        }
    }
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'ClassBody',
        body: body
    });
};
// http://www.ecma-international.org/ecma-262/8.0/#prod-ClassElement
Parser.prototype.parseClassElement = function parseClassElement (context, state) {
    var pos = this.getLocation();
    // Private fields / Private methods
    if (context & 1 /* OptionsNext */ && this.token === 118 /* Hash */) {
        this.expect(context, 118 /* Hash */);
        // E.g. 'class A { #constructor }'
        if (this.tokenValue === 'constructor')
            { this.report(22 /* PrivateFieldConstructor */); }
        state |= 4096 /* PrivateName */;
        var privateFieldKey = this.parsePrivateName(context, pos);
        return this.token === 1073872907 /* LeftParen */ ?
            this.parseFieldOrMethodDeclaration(context, state | 128 /* Method */, privateFieldKey, pos) :
            this.parseFieldDefinition(context, state, privateFieldKey, pos);
    }
    var t = this.token;
    var tokenValue = this.tokenValue;
    var mutuableFlag = 0 /* None */;
    var key;
    if (t & 67108864 /* IsGenerator */) {
        this.expect(context, 67766835 /* Multiply */);
        state |= 16 /* Generator */;
    }
    if (this.token === 537002003 /* LeftBracket */)
        { state |= 2 /* Computed */; }
    key = this.parsePropertyName(context);
    if (t === 20586 /* StaticKeyword */) {
        if (this.token & 1073741824 /* IsShorthand */) {
            return this.token === 1073872907 /* LeftParen */ ?
                this.parseFieldOrMethodDeclaration(context, state | 128 /* Method */, key, pos) :
                this.parseFieldDefinition(context, state, key, pos);
        }
        if (this.token === 118 /* Hash */)
            { this.report(0 /* Unexpected */); }
        t = this.token;
        state |= 1 /* Static */;
        if (t & 67108864 /* IsGenerator */) {
            this.expect(context, 67766835 /* Multiply */);
            state |= 16 /* Generator */;
        }
        if (this.tokenValue === 'prototype') {
            this.report(21 /* StaticPrototype */);
        }
        if (this.tokenValue === 'constructor') {
            tokenValue = this.tokenValue;
        }
        if (this.token === 537002003 /* LeftBracket */)
            { state |= 2 /* Computed */; }
        key = this.parsePropertyName(context);
    }
    // Forbids:  (',  '}',  ',',  ':',  '='
    if (!(this.token & 1073741824 /* IsShorthand */)) {
        if (t & 33554432 /* IsAsync */ && !(state & 16 /* Generator */) && !(this.flags & 1 /* LineTerminator */)) {
            state |= 32 /* Async */;
            t = this.token;
            if (context & 1 /* OptionsNext */ && this.token === 118 /* Hash */) {
                this.expect(context, 118 /* Hash */);
                if (this.tokenValue === 'constructor') {
                    this.report(22 /* PrivateFieldConstructor */);
                }
                state |= 4096 /* PrivateName */;
                key = this.parsePrivateName(context, pos);
            }
            else {
                if (t & 67108864 /* IsGenerator */) {
                    state |= 16 /* Generator */;
                    this.expect(context, 67766835 /* Multiply */);
                }
                if (this.token === 537002003 /* LeftBracket */)
                    { state |= 2 /* Computed */; }
                key = this.parsePropertyName(context);
            }
        }
        else if (t === 69744 /* GetKeyword */ || t === 69745 /* SetKeyword */) {
            if (!(state & 1 /* Static */) && this.tokenValue === 'constructor') {
                this.report(20 /* ConstructorSpecialMethod */);
            }
            state |= t === 69744 /* GetKeyword */ ? 8 /* Get */ : 4 /* Set */;
            if (this.token === 537002003 /* LeftBracket */)
                { state |= 2 /* Computed */; }
            mutuableFlag = this.flags;
            key = this.parsePropertyName(context);
            if (this.token === 1073872907 /* LeftParen */) {
                if (state & 1 /* Static */ && this.tokenValue === 'prototype') {
                    this.report(21 /* StaticPrototype */);
                }
                return this.parseFieldOrMethodDeclaration(context, state | 128 /* Method */, key, pos);
            }
        }
    }
    if (!(state & 2 /* Computed */)) {
        if (!(state & 1 /* Static */) && this.tokenValue === 'constructor') {
            state |= 64 /* Constructor */;
            if (state & 60 /* Special */) {
                this.tolerate(context, state & 16 /* Generator */ ? 116 /* ConstructorIsGenerator */ : 20 /* ConstructorSpecialMethod */);
            }
            if (state & 2048 /* HasConstructor */) {
                this.tolerate(context, 24 /* DuplicateConstructor */);
            }
        }
    }
    // Method
    if (key && this.token === 1073872907 /* LeftParen */) {
        if (state & 1024 /* Heritage */ && state & 64 /* Constructor */) {
            context |= 524288 /* AllowSuperProperty */;
        }
        return this.parseFieldOrMethodDeclaration(context, state | 128 /* Method */, key, pos);
    }
    if (context & 1 /* OptionsNext */) {
        if (t & (16777216 /* IsIdentifier */ | 4096 /* Keyword */) ||
            state & (4096 /* PrivateName */ | 2 /* Computed */) ||
            this.token === 17 /* Semicolon */ ||
            this.token === 1074003997 /* Assign */) {
            if (tokenValue === 'constructor')
                { this.report(23 /* ConstructorClassField */); }
            if (state & 1 /* Static */) {
                // Edge case - 'static a\n get', 'static get\n *a(){}'
                if (state & 12 /* Accessors */ && !(mutuableFlag & 1 /* LineTerminator */)) {
                    this.report(0 /* Unexpected */);
                }
                if (state & 16 /* Generator */) {
                    this.report(0 /* Unexpected */);
                }
            }
            if (state & 32 /* Async */) {
                this.report(21 /* StaticPrototype */);
            }
            return this.parseFieldDefinition(context, state, key, pos);
        }
    }
    this.report(1 /* UnexpectedToken */, tokenDesc(this.token));
};
Parser.prototype.parseFieldDefinition = function parseFieldDefinition (context, state, key, pos) {
    var value = null;
    if (this.consume(context, 1074003997 /* Assign */)) {
        if (this.token & 8388608 /* IsEvalArguments */)
            { this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */); }
        value = this.parseAssignmentExpression(context);
        // ASI requires that the next token is not part of any legal production
        if (state & 1 /* Static */) {
            this.consumeSemicolon(context);
        }
    }
    this.consume(context, 1073741842 /* Comma */);
    return this.finishNode(context, pos, {
        type: 'FieldDefinition',
        key: key,
        value: value,
        computed: !!(state & 2 /* Computed */),
        static: !!(state & 1 /* Static */)
    });
};
Parser.prototype.parseFieldOrMethodDeclaration = function parseFieldOrMethodDeclaration (context, state, key, pos) {
    return this.finishNode(context, pos, {
        type: 'MethodDefinition',
        kind: (state & 64 /* Constructor */) ? 'constructor' : (state & 8 /* Get */) ? 'get' :
            (state & 4 /* Set */) ? 'set' : 'method',
        static: !!(state & 1 /* Static */),
        computed: !!(state & 2 /* Computed */),
        key: key,
        value: this.parseMethodDeclaration(context & ~(32768 /* AllowYield */ | 65536 /* AllowAsync */ | 256 /* AllowIn */) | 8388608 /* Method */, state)
    });
};
Parser.prototype.parsePrivateName = function parsePrivateName (context, pos) {
    var name = this.tokenValue;
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'PrivateName',
        name: name
    });
};
Parser.prototype.parseArrowFunctionExpression = function parseArrowFunctionExpression (context, pos, params, formalArgs) {
        var this$1 = this;
        if ( formalArgs === void 0 ) formalArgs = [];

    if (this.flags & 1 /* LineTerminator */) {
        this.tolerate(context, 12 /* LineBreakAfterArrow */);
    }
    // Invalid: 'new () => {};'
    // Valid: 'new (() => {});'
    if (!(context & 33554432 /* InParenthesis */) &&
        context & 268435456 /* DisallowArrow */) {
        this.tolerate(context, 88 /* InvalidArrowConstructor */);
    }
    this.expect(context, 10 /* Arrow */);
    if (context & 67108864 /* InClass */ && this.token & 8388608 /* IsEvalArguments */) {
        this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */);
    }
    for (var i in params) {
        this$1.reinterpret(context | 16384 /* InParameter */, params[i]);
    }
    var body;
    var expression = false;
    if (this.token === 537001996 /* LeftBrace */) {
        // Multiple statement body
        body = this.parseFunctionBody(context | 256 /* AllowIn */ | 131072 /* ArrowFunction */, formalArgs);
        if ((context & 33554432 /* InParenthesis */) &&
            (hasBit(this.token, 655360 /* IsBinaryOp */) ||
                this.token === 1073872907 /* LeftParen */ ||
                this.token === 22 /* QuestionMark */)) {
            this.report(1 /* UnexpectedToken */, tokenDesc(this.token));
        }
    }
    else {
        // Single-expression body
        expression = true;
        this.validateParams(context, formalArgs);
        body = this.parseAssignmentExpression(context | 256 /* AllowIn */);
    }
    return this.finishNode(context, pos, {
        type: 'ArrowFunctionExpression',
        body: body,
        params: params,
        id: null,
        async: !!(context & 65536 /* AllowAsync */),
        generator: !!(context & 32768 /* AllowYield */),
        expression: expression
    });
};
Parser.prototype.parseRestElement = function parseRestElement (context, params) {
        if ( params === void 0 ) params = [];

    var pos = this.getLocation();
    this.expect(context, 14 /* Ellipsis */);
    var argument = this.parseBindingIdentifierOrBindingPattern(context, params);
    return this.finishNode(context, pos, {
        type: 'RestElement',
        argument: argument
    });
};
// https://tc39.github.io/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList
Parser.prototype.parseExpressionCoverGrammar = function parseExpressionCoverGrammar (context) {
        var this$1 = this;

    var pos = this.getLocation();
    this.expect(context, 1073872907 /* LeftParen */);
    if (this.consume(context, 16 /* RightParen */) && this.token === 10 /* Arrow */) {
        return this.parseArrowFunctionExpression(context & ~(65536 /* AllowAsync */ | 32768 /* AllowYield */), pos, []);
    }
    var expr;
    var state = 0 /* None */;
    var params = [];
    if (this.token === 14 /* Ellipsis */) {
        expr = this.parseRestElement(context, params);
        this.expect(context, 16 /* RightParen */);
        return this.parseArrowFunctionExpression(context & ~(65536 /* AllowAsync */ | 32768 /* AllowYield */), pos, [expr], params);
    }
    var sequencepos = this.getLocation();
    var isSequence = false;
    if (context & 32768 /* AllowYield */ && hasBit(this.token, 268435456 /* IsYield */)) {
        this.errorLocation = this.getLocation();
        this.flags |= 4096 /* HasYield */;
    }
    // Maybe nested parenthesis - ((foo))
    if (this.token === 1073872907 /* LeftParen */) {
        this.errorLocation = this.getLocation();
        state |= 1 /* NestedParenthesis */;
    }
    // Start of a binding pattern inside parenthesis - '({foo: bar})', '{[()]}'
    if (hasBit(this.token, 536870912 /* IsBindingPattern */)) {
        this.errorLocation = this.getLocation();
        state |= 2 /* BindingPattern */;
    }
    // The parenthesis contain a future reserved word. Flag it and throw
    // later on if it turns out that we are in a strict mode context
    if (hasBit(this.token, 20480 /* FutureReserved */)) {
        this.errorLocation = this.getLocation();
        state |= 4 /* FutureReserved */;
    }
    if (hasBit(this.token, 8388608 /* IsEvalArguments */)) {
        this.errorLocation = this.getLocation();
        state |= 8 /* EvalOrArguments */;
    }
    if (this.token & 16777216 /* IsIdentifier */) {
        params.push(this.tokenValue);
    }
    expr = this.parseAssignmentExpression(context);
    if (this.token === 1073741842 /* Comma */) {
        var expressions = [expr];
        while (this.consume(context, 1073741842 /* Comma */)) {
            // If found a 'RightParen' token here, then this is a trailing comma, which
            // is allowed before the closing parenthesis in an arrow
            // function parameters list. E.g. `(a, b, ) => body`.
            if (this$1.consume(context, 16 /* RightParen */)) {
                if (this$1.token === 10 /* Arrow */) {
                    return this$1.parseArrowFunctionExpression(context & ~(65536 /* AllowAsync */ | 32768 /* AllowYield */), pos, expressions, params);
                }
            }
            else if (this$1.token === 14 /* Ellipsis */) {
                expressions.push(this$1.parseRestElement(context, params));
                this$1.expect(context, 16 /* RightParen */);
                if (state & 1 /* NestedParenthesis */) {
                    this$1.tolerate(context, 13 /* InvalidParenthesizedPattern */);
                }
                return this$1.parseArrowFunctionExpression(context & ~(65536 /* AllowAsync */ | 32768 /* AllowYield */), pos, expressions, params);
            }
            else {
                // Maybe nested parenthesis as a second, third, forth
                // param etc - '(foo, (foo))', '(foo, bar, (baz))'
                if (this$1.token === 1073872907 /* LeftParen */) {
                    // this.errorLocation = this.getLocation();
                    state |= 1 /* NestedParenthesis */;
                }
                if (hasBit(this$1.token, 8388608 /* IsEvalArguments */)) {
                    // this.errorLocation = this.getLocation();
                    state |= 8 /* EvalOrArguments */;
                }
                if (this$1.token & 16777216 /* IsIdentifier */) {
                    params.push(this$1.tokenValue);
                }
                expressions.push(this$1.parseAssignmentExpression(context));
            }
        }
        isSequence = true;
        expr = this.finishNode(context, sequencepos, {
            type: 'SequenceExpression',
            expressions: expressions
        });
    }
    this.expect(context, 16 /* RightParen */);
    if (this.token === 10 /* Arrow */) {
        if (state & 2 /* BindingPattern */) {
            this.flags |= 32 /* SimpleParameterList */;
        }
        if (state & 4 /* FutureReserved */) {
            this.errorLocation = this.getLocation();
            this.flags |= 8192 /* ReservedWords */;
        }
        if (state & 1 /* NestedParenthesis */) {
            this.tolerate(context, 13 /* InvalidParenthesizedPattern */);
        }
        if (this.flags & 4096 /* HasYield */) {
            this.tolerate(context, 65 /* InvalidArrowYieldParam */);
        }
        if (state & 8 /* EvalOrArguments */) {
            // Invalid: '"use strict"; (eval = 10) => 42;'
            if (context & 512 /* Strict */)
                { this.tolerate(context, 92 /* UnexpectedStrictEvalOrArguments */); }
            // Invalid: '(eval = 10) => { "use strict"; }'
            this.errorLocation = this.getLocation();
            this.flags |= 8192 /* ReservedWords */;
        }
        return this.parseArrowFunctionExpression(context & ~(65536 /* AllowAsync */ | 32768 /* AllowYield */), pos, isSequence ? expr.expressions : [expr], params);
    }
    this.flags &= ~4096 /* HasYield */;
    return expr;
};
Parser.prototype.parseRegularExpressionLiteral = function parseRegularExpressionLiteral (context) {
    var pos = this.getLocation();
    var regex = this.tokenRegExp;
    var value = this.tokenValue;
    var raw = this.tokenRaw;
    this.nextToken(context);
    var node = this.finishNode(context, pos, {
        type: 'Literal',
        value: value,
        regex: regex
    });
    if (context & 8 /* OptionsRaw */)
        { node.raw = raw; }
    return node;
};
Parser.prototype.parseNullOrTrueOrFalseExpression = function parseNullOrTrueOrFalseExpression (context, pos) {
    if (this.flags & 512 /* HasEscapedKeyword */)
        { this.tolerate(context, 36 /* UnexpectedEscapedKeyword */); }
    var t = this.token;
    var raw = tokenDesc(t);
    this.nextToken(context);
    var node = this.finishNode(context, pos, {
        type: 'Literal',
        value: t === 143367 /* NullKeyword */ ? null : raw === 'true'
    });
    if (context & 8 /* OptionsRaw */)
        { node.raw = raw; }
    return node;
};
Parser.prototype.parseThisExpression = function parseThisExpression (context) {
    var pos = this.getLocation();
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'ThisExpression'
    });
};
Parser.prototype.parseBigIntLiteral = function parseBigIntLiteral (context, pos) {
    var value = this.tokenValue;
    var raw = this.tokenRaw;
    this.nextToken(context);
    var node = this.finishNode(context, pos, {
        type: 'Literal',
        value: value,
        bigint: raw
    });
    if (context & 8 /* OptionsRaw */)
        { node.raw = raw; }
    return node;
};
Parser.prototype.parseLiteral = function parseLiteral (context) {
    var pos = this.getLocation();
    var raw = this.tokenRaw;
    var value = this.tokenValue;
    if (context & 512 /* Strict */ && this.flags & 64 /* Octal */) {
        this.tolerate(context, 39 /* StrictOctalLiteral */);
    }
    this.nextToken(context);
    var node = this.finishNode(context, pos, {
        type: 'Literal',
        value: value
    });
    if (context & 8 /* OptionsRaw */)
        { node.raw = raw; }
    return node;
};
Parser.prototype.parseIdentifier = function parseIdentifier (context) {
    var pos = this.getLocation();
    var name = this.tokenValue;
    this.nextToken(context | 2048 /* TaggedTemplate */);
    return this.finishNode(context, pos, {
        type: 'Identifier',
        name: name
    });
};
Parser.prototype.parseBindingIdentifierOrBindingPattern = function parseBindingIdentifierOrBindingPattern (context, params) {
        if ( params === void 0 ) params = [];

    var t = this.token;
    if (t & (134217728 /* IsAwait */ | 268435456 /* IsYield */)) {
        if (t & 134217728 /* IsAwait */ && (context & (65536 /* AllowAsync */ | 1024 /* Module */))) {
            this.tolerate(context, 52 /* UnexpectedReservedWord */);
        }
        else if (t & 268435456 /* IsYield */ && (context & (32768 /* AllowYield */ | 512 /* Strict */))) {
            this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(this.token));
        }
    }
    if (!(t & 536870912 /* IsBindingPattern */)) {
        params.push(this.tokenValue);
        return this.parseBindingIdentifier(context);
    }
    if (t === 537001996 /* LeftBrace */)
        { return this.ObjectAssignmentPattern(context, params); }
    return this.parseArrayElementsBindingPattern(context, params);
};
// https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
Parser.prototype.parseAssignmentRestElement = function parseAssignmentRestElement (context, params) {
        if ( params === void 0 ) params = [];

    var pos = this.getLocation();
    this.expect(context, 14 /* Ellipsis */);
    var argument = this.parseBindingIdentifierOrBindingPattern(context, params);
    return this.finishNode(context, pos, {
        type: 'RestElement',
        argument: argument
    });
};
Parser.prototype.parseAssignmentPattern = function parseAssignmentPattern (context, params, pos, pattern) {
        if ( pos === void 0 ) pos = this.getLocation();
        if ( pattern === void 0 ) pattern = this.parseBindingIdentifierOrBindingPattern(context, params);

    if (!this.consume(context, 1074003997 /* Assign */))
        { return pattern; }
    if (context & 32768 /* AllowYield */ && this.token & 268435456 /* IsYield */) {
        this.errorLocation = this.getLocation();
        this.flags |= 4096 /* HasYield */;
    }
    if (this.token & 134217728 /* IsAwait */) {
        this.errorLocation = this.getLocation();
        this.flags |= 2048 /* HasAwait */;
    }
    return this.finishNode(context, pos, {
        type: 'AssignmentPattern',
        left: pattern,
        right: this.parseAssignmentExpression(context)
    });
};
Parser.prototype.parseArrayElementsBindingPattern = function parseArrayElementsBindingPattern (context, params) {
        var this$1 = this;
        if ( params === void 0 ) params = [];

    var pos = this.getLocation();
    this.expect(context, 537002003 /* LeftBracket */);
    var elements = [];
    while (this.token !== 20 /* RightBracket */) {
        if (this$1.token === 14 /* Ellipsis */) {
            elements.push(this$1.parseAssignmentRestElement(context, params));
            break;
        }
        if (this$1.consume(context, 1073741842 /* Comma */)) {
            elements.push(null);
        }
        else {
            elements.push(this$1.parseAssignmentPattern(context | 256 /* AllowIn */, params));
            this$1.consume(context, 1073741842 /* Comma */);
        }
    }
    this.expect(context, 20 /* RightBracket */);
    return this.finishNode(context, pos, {
        type: 'ArrayPattern',
        elements: elements
    });
};
Parser.prototype.parseRestProperty = function parseRestProperty (context, params) {
    var pos = this.getLocation();
    this.expect(context, 14 /* Ellipsis */);
    // Object rest spread must be followed by an identifier in declaration contexts
    if (!(this.token & 16777216 /* IsIdentifier */))
        { this.tolerate(context, 40 /* InvalidRestBindingPattern */); }
    var arg = this.parseBindingIdentifierOrBindingPattern(context, params);
    if (this.token === 1074003997 /* Assign */)
        { this.tolerate(context, 40 /* InvalidRestBindingPattern */); }
    // Rest element must be last element
    if (this.token !== 1073741839 /* RightBrace */)
        { this.tolerate(context, 42 /* ElementAfterRest */); }
    return this.finishNode(context, pos, {
        type: 'RestElement',
        argument: arg
    });
};
Parser.prototype.ObjectAssignmentPattern = function ObjectAssignmentPattern (context, params) {
        var this$1 = this;

    var pos = this.getLocation();
    var properties = [];
    this.expect(context, 537001996 /* LeftBrace */);
    while (this.token !== 1073741839 /* RightBrace */) {
        if (this$1.token === 14 /* Ellipsis */) {
            properties.push(this$1.parseRestProperty(context, params));
            // Comma is not permitted after the rest element
        }
        else {
            properties.push(this$1.parseAssignmentProperty(context, params));
            if (this$1.token !== 1073741839 /* RightBrace */)
                { this$1.consume(context, 1073741842 /* Comma */); }
        }
    }
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'ObjectPattern',
        properties: properties
    });
};
Parser.prototype.parseAssignmentProperty = function parseAssignmentProperty (context, params) {
        if ( params === void 0 ) params = [];

    var pos = this.getLocation();
    var state = 0 /* None */;
    var key;
    var value;
    var t = this.token;
    if (t & (16777216 /* IsIdentifier */ | 4096 /* Keyword */)) {
        t = this.token;
        key = this.parseIdentifier(context);
        if (!this.consume(context, 1073741845 /* Colon */))
            { state |= 256 /* Shorthand */; }
        if (state & 256 /* Shorthand */) {
            if (context & (32768 /* AllowYield */ | 512 /* Strict */) && t & 268435456 /* IsYield */) {
                this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
            }
            value = this.parseAssignmentPattern(context, params, pos, key);
        }
        else {
            value = this.parseAssignmentPattern(context, params);
        }
    }
    else {
        if (t === 537002003 /* LeftBracket */)
            { state |= 2 /* Computed */; }
        key = this.parsePropertyName(context);
        this.expect(context, 1073741845 /* Colon */);
        value = this.parseAssignmentPattern(context, params);
    }
    return this.finishNode(context, pos, {
        type: 'Property',
        kind: 'init',
        key: key,
        computed: !!(state & 2 /* Computed */),
        value: value,
        method: false,
        shorthand: !!(state & 256 /* Shorthand */)
    });
};
// https://tc39.github.io/ecma262/#sec-variable-statement
Parser.prototype.parseBindingIdentifier = function parseBindingIdentifier (context) {
    var t = this.token;
    if (!this.isIdentifier(context, t)) {
        this.reportUnexpectedTokenOrKeyword();
    }
    if (context & 512 /* Strict */ && t & 8388608 /* IsEvalArguments */) {
        this.tolerate(context, 60 /* InvalidBindingStrictMode */, tokenDesc(t));
    }
    if (context & 6291456 /* BlockScoped */ && t === 151624 /* LetKeyword */) {
        this.tolerate(context, 50 /* LetInLexicalBinding */);
    }
    var name = this.tokenValue;
    var pos = this.getLocation();
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'Identifier',
        name: name
    });
};
Parser.prototype.parseIdentifierName = function parseIdentifierName (context, t) {
    if (!(t & (16777216 /* IsIdentifier */ | 4096 /* Keyword */)))
        { this.reportUnexpectedTokenOrKeyword(); }
    return this.parseIdentifier(context);
};
Parser.prototype.parseFunctionName = function parseFunctionName (context) {
    if (this.token & 8388608 /* IsEvalArguments */) {
        if (context & (512 /* Strict */ | 65536 /* AllowAsync */))
            { this.tolerate(context, 29 /* StrictLHSAssignment */); }
        this.errorLocation = this.getLocation();
        this.flags |= 8192 /* ReservedWords */;
    }
    return !(context & (512 /* Strict */ | 32768 /* AllowYield */)) && this.token === 268587115 /* YieldKeyword */ ?
        this.parseIdentifierName(context, this.token) :
        this.parseBindingIdentifier(context);
};
Parser.prototype.parseFunctionDeclaration = function parseFunctionDeclaration (context) {
    var pos = this.getLocation();
    var id = null;
    var prevContext = context;
    // Unset masks Object / Class Method, and disallow derived class constructors in this context
    context &= ~(8388608 /* Method */ | 524288 /* AllowSuperProperty */ | 65536 /* AllowAsync */ | 32768 /* AllowYield */);
    if (this.consume(context, 33624173 /* AsyncKeyword */))
        { context |= 65536 /* AllowAsync */; }
    this.expect(context, 143448 /* FunctionKeyword */);
    if (this.consume(context, 67766835 /* Multiply */)) {
        if (context & 4096 /* AnnexB */)
            { this.tolerate(context, 71 /* GeneratorLabel */); }
        context |= 32768 /* AllowYield */;
    }
    if (this.token !== 1073872907 /* LeftParen */) {
        var t = this.token;
        if ((prevContext & (65536 /* AllowAsync */ | 1024 /* Module */) && t & 134217728 /* IsAwait */) ||
            (prevContext & 32768 /* AllowYield */ && t & 268435456 /* IsYield */)) {
            this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
        }
        id = this.parseFunctionName(context);
    }
    else if (!(context & 134217728 /* RequireIdentifier */)) {
        this.tolerate(context, 62 /* UnNamedFunctionStmt */);
    }
    return this.parseFunction(context & ~(4096 /* AnnexB */ | 134217728 /* RequireIdentifier */), id, pos);
};
Parser.prototype.parseFunctionExpression = function parseFunctionExpression (context, isAsync, pos) {
        if ( isAsync === void 0 ) isAsync = false;
        if ( pos === void 0 ) pos = this.getLocation();

    var id = null;
    // Unset masks Object / Class Method, and disallow derived class constructors in this context
    context &= ~(8388608 /* Method */ | 524288 /* AllowSuperProperty */ | 32768 /* AllowYield */);
    if (!isAsync) {
        if (this.consume(context, 33624173 /* AsyncKeyword */))
            { context |= 65536 /* AllowAsync */; }
        else
            { context &= ~65536 /* AllowAsync */; }
    }
    this.expect(context, 143448 /* FunctionKeyword */);
    if (this.consume(context, 67766835 /* Multiply */)) {
        if (context & 4096 /* AnnexB */)
            { this.tolerate(context, 71 /* GeneratorLabel */); }
        context |= 32768 /* AllowYield */;
    }
    if (this.token !== 1073872907 /* LeftParen */) {
        var t = this.token;
        if ((context & 65536 /* AllowAsync */ && t & 134217728 /* IsAwait */) ||
            (context & 32768 /* AllowYield */ && t & 268435456 /* IsYield */)) {
            this.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(t));
        }
        id = this.parseFunctionName(context);
    }
    return this.parseFunction(context, id, pos);
};
Parser.prototype.parseFunction = function parseFunction (context, id, pos, state /* None */) {
        if ( id === void 0 ) id = null;
        if ( state === void 0 ) state = 0;

    var formalParameters = this.parseFormalParameterList(context | 16384 /* InParameter */, state);
    var args = formalParameters.args;
    var params = formalParameters.params;
    var body = this.parseFunctionBody(context & ~8192 /* Expression */, args);
    return this.finishNode(context, pos, {
        type: context & (8192 /* Expression */ | 8388608 /* Method */) ? 'FunctionExpression' : 'FunctionDeclaration',
        params: params,
        body: body,
        async: !!(context & 65536 /* AllowAsync */),
        generator: !!(context & 32768 /* AllowYield */),
        expression: false,
        id: id
    });
};
// https://tc39.github.io/ecma262/#sec-function-definitions
Parser.prototype.parseFunctionBody = function parseFunctionBody (context, params) {
        var this$1 = this;
        if ( params === void 0 ) params = [];

    var pos = this.getLocation();
    var body = [];
    this.expect(context, 537001996 /* LeftBrace */);
    if (this.token !== 1073741839 /* RightBrace */) {
        var savedFlags = this.flags;
        this.flags |= 16 /* InFunctionBody */;
        var previousLabelSet = this.labelSet;
        this.labelSet = undefined;
        this.flags |= 16 /* InFunctionBody */;
        this.flags &= ~(8 /* AllowBreak */ | 4 /* AllowContinue */);
        while (this.token === 131075 /* StringLiteral */) {
            var item = this$1.parseDirective(context);
            body.push(item);
            if (!isPrologueDirective(item))
                { break; }
            if (this$1.flags & 1024 /* StrictDirective */) {
                if (this$1.flags & 32 /* SimpleParameterList */) {
                    this$1.tolerate(context, 66 /* IllegalUseStrict */);
                }
                if (this$1.flags & 8192 /* ReservedWords */)
                    { this$1.tolerate(context, 14 /* UnexpectedStrictReserved */); }
                context |= 512 /* Strict */;
            }
        }
        while (this.token !== 1073741839 /* RightBrace */) {
            body.push(this$1.parseStatementListItem(context));
        }
        this.labelSet = previousLabelSet;
        this.flags = savedFlags;
    }
    this.expect(context, 1073741839 /* RightBrace */);
    if (context & (512 /* Strict */ | 131072 /* ArrowFunction */))
        { this.validateParams(context, params); }
    return this.finishNode(context, pos, {
        type: 'BlockStatement',
        body: body
    });
};
Parser.prototype.parseFormalParameterList = function parseFormalParameterList (context, state) {
        var this$1 = this;

    this.flags &= ~32 /* SimpleParameterList */;
    var args = [];
    var params = [];
    this.expect(context, 1073872907 /* LeftParen */);
    while (this.token !== 16 /* RightParen */) {
        if (this$1.token === 14 /* Ellipsis */) {
            this$1.flags |= 32 /* SimpleParameterList */;
            if (state & 4 /* Set */) {
                this$1.tolerate(context, 4 /* BadSetterRestParameter */);
            }
            params.push(this$1.parseRestElement(context, args));
            // Invalid: 'class { static async *method(...a,) { } };'
            if (this$1.token === 1073741842 /* Comma */) {
                this$1.tolerate(context, 7 /* ParamAfterRest */);
            }
            if (this$1.token === 1074003997 /* Assign */) {
                this$1.tolerate(context, 43 /* InitializerAfterRest */);
            }
        }
        else {
            var pos = this$1.getLocation();
            if (!(this$1.token & 16777216 /* IsIdentifier */)) {
                this$1.flags |= 32 /* SimpleParameterList */;
            }
            if (this$1.token & 8388608 /* IsEvalArguments */) {
                if (context & 512 /* Strict */)
                    { this$1.tolerate(context, 29 /* StrictLHSAssignment */); }
                this$1.errorLocation = this$1.getLocation();
                this$1.flags |= 8192 /* ReservedWords */;
            }
            if (this$1.token & 20480 /* FutureReserved */)
                { this$1.flags |= 8192 /* ReservedWords */; }
            var left = this$1.parseBindingIdentifierOrBindingPattern(context, args);
            if (this$1.consume(context, 1074003997 /* Assign */)) {
                this$1.flags |= 32 /* SimpleParameterList */;
                if (this$1.token & (268435456 /* IsYield */ | 134217728 /* IsAwait */) && context & (32768 /* AllowYield */ | 65536 /* AllowAsync */)) {
                    this$1.tolerate(context, 18 /* DisallowedInContext */, tokenDesc(this$1.token));
                }
                params.push(this$1.finishNode(context, pos, {
                    type: 'AssignmentPattern',
                    left: left,
                    right: this$1.parseAssignmentExpression(context)
                }));
            }
            else {
                params.push(left);
            }
        }
        if (this$1.token === 16 /* RightParen */)
            { break; }
        this$1.expect(context, 1073741842 /* Comma */);
        if (this$1.token === 16 /* RightParen */)
            { break; }
    }
    if (context & 8388608 /* Method */) {
        if (state & 8 /* Get */ && params.length > 0) {
            this.tolerate(context, 2 /* BadGetterArity */);
        }
        if (state & 4 /* Set */ && params.length !== 1) {
            this.tolerate(context, 3 /* BadSetterArity */);
        }
    }
    this.expect(context, 16 /* RightParen */);
    return {
        params: params,
        args: args
    };
};
// https://tc39.github.io/ecma262/#sec-for-statement
// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
Parser.prototype.parseForStatement = function parseForStatement (context) {
        var this$1 = this;

    var pos = this.getLocation();
    this.expect(context, 12375 /* ForKeyword */);
    var awaitToken = !!(context & 65536 /* AllowAsync */) && this.consume(context, 134418542 /* AwaitKeyword */);
    this.expect(context, 1073872907 /* LeftParen */);
    var init = null;
    var type = 'ForStatement';
    var test = null;
    var update = null;
    var declarations;
    var right;
    context |= 16777216 /* ForStatement */ | 1048576 /* ValidateEscape */;
    var sequencePos;
    var t = this.token;
    var savedFlag = this.flags;
    if (t !== 17 /* Semicolon */) {
        // 'var', let', 'const
        if (t === 143431 /* VarKeyword */ ||
            t === 151624 /* LetKeyword */ ||
            t === 143433 /* ConstKeyword */) {
            switch (t) {
                case 151624 /* LetKeyword */:
                    {
                        if (!this.isLexical(context)) {
                            init = this.parseExpression(context & ~256 /* AllowIn */, pos);
                            break;
                        }
                    }
                    context |= 2097152 /* Let */;
                    break;
                // falls through
                case 143433 /* ConstKeyword */:
                    context |= 4194304 /* Const */;
                default: // ignore
            }
            if (!init) {
                var startPos = this.getLocation();
                this.nextToken(context);
                declarations = this.parseVariableDeclarationList(context);
                init = this.finishNode(context, startPos, {
                    type: 'VariableDeclaration',
                    declarations: declarations,
                    kind: tokenDesc(t)
                });
            }
        }
        else {
            sequencePos = this.getLocation();
            init = this.parseAssignmentExpression(context & ~256 /* AllowIn */);
        }
    }
    this.flags |= (4 /* AllowContinue */ | 8 /* AllowBreak */);
    switch (this.token) {
        case 69747 /* OfKeyword */:
            {
                this.expect(context, 69747 /* OfKeyword */);
                type = 'ForOfStatement';
                right = this.parseAssignmentExpression(context | 256 /* AllowIn */);
                if (!declarations) {
                    this.reinterpret(context, init);
                }
                break;
            }
        case 669489 /* InKeyword */:
            {
                if (awaitToken)
                    { this.report(0 /* Unexpected */); }
                this.expect(context, 669489 /* InKeyword */);
                type = 'ForInStatement';
                right = this.parseExpression(context | 256 /* AllowIn */, pos);
                if (!declarations) {
                    if (!isValidDestructuringAssignmentTarget(init) || init.type === 'AssignmentExpression') {
                        this.tolerate(context, 63 /* InvalidLHSInForLoop */);
                    }
                    this.reinterpret(context, init);
                }
                break;
            }
        default:
            if (awaitToken)
                { this.report(0 /* Unexpected */); }
            if (this.token === 1073741842 /* Comma */) {
                var initSeq = [init];
                while (this.consume(context, 1073741842 /* Comma */)) {
                    initSeq.push(this$1.parseAssignmentExpression(context));
                }
                init = this.finishNode(context, sequencePos, {
                    type: 'SequenceExpression',
                    expressions: initSeq
                });
            }
            this.expect(context, 17 /* Semicolon */);
            test = this.token !== 17 /* Semicolon */ ?
                this.parseExpression(context | 256 /* AllowIn */, pos) :
                null;
            this.expect(context, 17 /* Semicolon */);
            update = this.token !== 16 /* RightParen */ ?
                this.parseExpression(context | 256 /* AllowIn */, pos) :
                null;
    }
    this.expect(context, 16 /* RightParen */);
    var body = this.parseStatement(context & ~1073741824 /* AllowSingleStatement */);
    this.flags = savedFlag;
    return this.finishNode(context, pos, type === 'ForOfStatement' ? {
        type: type,
        body: body,
        left: init,
        right: right,
        await: awaitToken,
    } : right ? {
        type: type,
        body: body,
        left: init,
        right: right
    } : {
        type: type,
        body: body,
        init: init,
        test: test,
        update: update
    });
};
/** JSX */
Parser.prototype.parseJSXChildren = function parseJSXChildren (context) {
        var this$1 = this;

    var children = [];
    while (this.token !== 25 /* JSXClose */) {
        children.push(this$1.parseJSXChild(context | 8192 /* Expression */, this$1.getLocation()));
    }
    return children;
};
Parser.prototype.parseJSXChild = function parseJSXChild (context, pos) {
    switch (this.token) {
        case 132 /* JSXText */:
        case 16908289 /* Identifier */:
            return this.parseJSXText(context);
        case 537001996 /* LeftBrace */:
            return this.parseJSXExpressionContainer(context);
        case 657215 /* LessThan */:
            return this.parseJSXElementOrFragment(context & ~8192 /* Expression */);
        default: // ignore
    }
};
Parser.prototype.parseJSXSpreadChild = function parseJSXSpreadChild (context) {
    var pos = this.getLocation();
    this.expect(context, 14 /* Ellipsis */);
    var expression = this.parseExpression(context, pos);
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'JSXSpreadChild',
        expression: expression
    });
};
Parser.prototype.parseJSXText = function parseJSXText (context) {
    var pos = this.getLocation();
    var value = this.source.slice(this.startIndex, this.index);
    this.nextJSXToken();
    var node = this.finishNode(context, pos, {
        type: 'JSXText',
        value: value
    });
    if (context & 8 /* OptionsRaw */)
        { node.raw = value; }
    return node;
};
Parser.prototype.parseJSXEmptyExpression = function parseJSXEmptyExpression (context, pos) {
    return this.finishNode(context, pos, {
        type: 'JSXEmptyExpression'
    });
};
Parser.prototype.parseJSXExpressionContainer = function parseJSXExpressionContainer (context) {
    var pos = this.getLocation();
    this.expect(context, 537001996 /* LeftBrace */);
    if (this.token === 14 /* Ellipsis */) {
        return this.parseJSXSpreadChild(context);
    }
    var expression = this.token === 1073741839 /* RightBrace */ ?
        this.parseJSXEmptyExpression(context, pos) :
        this.parseAssignmentExpression(context);
    this.nextJSXToken();
    return this.finishNode(context, pos, {
        type: 'JSXExpressionContainer',
        expression: expression
    });
};
Parser.prototype.parseJSXClosingElement = function parseJSXClosingElement (context, state) {
    var pos = this.getLocation();
    this.expect(context, 25 /* JSXClose */);
    if (state & 2 /* Fragment */) {
        this.expect(context, 657216 /* GreaterThan */);
        return this.finishNode(context, pos, {
            type: 'JSXClosingFragment'
        });
    }
    var name = this.parseJSXElementName(context);
    if (context & 8192 /* Expression */) {
        this.expect(context, 657216 /* GreaterThan */);
    }
    else {
        this.nextJSXToken();
    }
    return this.finishNode(context, pos, {
        type: 'JSXClosingElement',
        name: name
    });
};
Parser.prototype.scanJSXString = function scanJSXString (context, quote) {
        var this$1 = this;

    var ret = '';
    this.advance();
    var ch = this.nextChar();
    while (ch !== quote) {
        ret += fromCodePoint(ch);
        ch = this$1.readNext(ch);
    }
    this.advance(); // Consume the quote
    if (context & 8 /* OptionsRaw */) {
        this.storeRaw(this.startIndex);
    }
    this.tokenValue = ret;
    return 131075 /* StringLiteral */;
};
Parser.prototype.scanJSXAttributeValue = function scanJSXAttributeValue (context) {
    this.startIndex = this.index;
    this.startColumn = this.column;
    this.startLine = this.line;
    var ch = this.nextChar();
    switch (ch) {
        case 34 /* DoubleQuote */:
        case 39 /* SingleQuote */:
            return this.scanJSXString(context, ch);
        default:
            this.nextToken(context);
    }
};
Parser.prototype.parseJSXSpreadAttribute = function parseJSXSpreadAttribute (context) {
    var pos = this.getLocation();
    this.expect(context, 537001996 /* LeftBrace */);
    this.expect(context, 14 /* Ellipsis */);
    var expression = this.parseExpression(context, pos);
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'JSXSpreadAttribute',
        argument: expression
    });
};
Parser.prototype.parseJSXAttributeName = function parseJSXAttributeName (context) {
    var pos = this.getLocation();
    var identifier = this.parseJSXIdentifier(context);
    if (this.token === 1073741845 /* Colon */) {
        return this.parseJSXNamespacedName(context, identifier, pos);
    }
    return identifier;
};
Parser.prototype.parseJSXAttribute = function parseJSXAttribute (context) {
    var pos = this.getLocation();
    var value = null;
    var attrName = this.parseJSXAttributeName(context);
    if (this.token === 1074003997 /* Assign */) {
        value = this.scanJSXAttributeValue(context) === 131075 /* StringLiteral */ ?
            this.parseLiteral(context) :
            this.parseJSXExpressionAttribute(context);
    }
    return this.finishNode(context, pos, {
        type: 'JSXAttribute',
        value: value,
        name: attrName
    });
};
Parser.prototype.parseJSXExpressionAttribute = function parseJSXExpressionAttribute (context) {
    var pos = this.getLocation();
    this.expect(context, 537001996 /* LeftBrace */);
    var expression = this.parseAssignmentExpression(context);
    this.expect(context, 1073741839 /* RightBrace */);
    return this.finishNode(context, pos, {
        type: 'JSXExpressionContainer',
        expression: expression
    });
};
Parser.prototype.parseJSXAttributes = function parseJSXAttributes (context) {
        var this$1 = this;

    var attributes = [];
    while (!(this.token === 657216 /* GreaterThan */ || this.token === 657973 /* Divide */)) {
        attributes.push(this$1.token === 537001996 /* LeftBrace */ ?
            this$1.parseJSXSpreadAttribute(context &= ~8192 /* Expression */) :
            this$1.parseJSXAttribute(context));
    }
    return attributes;
};
Parser.prototype.scanJSX = function scanJSX () {
        var this$1 = this;

    this.lastIndex = this.startIndex = this.index;
    switch (this.nextChar()) {
        case 60 /* LessThan */:
            {
                this.advance();
                if (!this.consumeOpt(47 /* Slash */))
                    { return 657215 /* LessThan */; }
                return 25 /* JSXClose */;
            }
        case 123 /* LeftBrace */:
            {
                this.advance();
                return 537001996 /* LeftBrace */;
            }
        default:
            loop: while (true) {
                switch (this$1.nextChar()) {
                    case 123 /* LeftBrace */:
                    case 60 /* LessThan */:
                        break loop;
                    default:
                        this$1.advance();
                }
            }
            return 132 /* JSXText */;
    }
};
Parser.prototype.nextJSXToken = function nextJSXToken () {
    this.token = this.scanJSX();
};
Parser.prototype.parseJSXIdentifier = function parseJSXIdentifier (context) {
    var name = this.tokenValue;
    var pos = this.getLocation();
    this.nextToken(context);
    return this.finishNode(context, pos, {
        type: 'JSXIdentifier',
        name: name
    });
};
Parser.prototype.parseJSXNamespacedName = function parseJSXNamespacedName (context, namespace, pos) {
    this.expect(context, 1073741845 /* Colon */);
    var name = this.parseJSXIdentifier(context);
    return this.finishNode(context, pos, {
        type: 'JSXNamespacedName',
        namespace: namespace,
        name: name
    });
};
Parser.prototype.parseJSXMemberExpression = function parseJSXMemberExpression (context, expr, pos) {
    return this.finishNode(context, pos, {
        type: 'JSXMemberExpression',
        object: expr,
        property: this.parseJSXIdentifier(context)
    });
};
Parser.prototype.parseJSXElementName = function parseJSXElementName (context) {
        var this$1 = this;

    var pos = this.getLocation();
    var expression = this.parseJSXIdentifier(context | 8192 /* Expression */);
    // Namespace
    if (this.token === 1073741845 /* Colon */) {
        return this.parseJSXNamespacedName(context, expression, pos);
    }
    // Member expression
    while (this.consume(context, 13 /* Period */)) {
        expression = this$1.parseJSXMemberExpression(context, expression, pos);
    }
    return expression;
};
Parser.prototype.parseJSXElementOrFragment = function parseJSXElementOrFragment (context) {
    var pos = this.getLocation();
    var t = this.token;
    this.expect(context, 657215 /* LessThan */);
    var openingElement = null;
    var state = 0 /* None */;
    if (this.token === 657216 /* GreaterThan */) {
        state |= 2 /* Fragment */;
        openingElement = this.parseJSXOpeningFragment(context, pos);
    }
    else {
        openingElement = this.parseJSXOpeningElement(context, state, pos);
        if (openingElement.selfClosing)
            { state |= 1 /* SelfClosing */; }
    }
    var children = [];
    var closingElement = null;
    if (state & 1 /* SelfClosing */) {
        return this.parseJSXElement(context, children, openingElement, null, pos);
    }
    children = this.parseJSXChildren(context);
    closingElement = this.parseJSXClosingElement(context, state);
    if (state & 2 /* Fragment */) {
        return this.parseFragment(context, children, openingElement, closingElement, pos);
    }
    var open = isQualifiedJSXName(openingElement.name);
    var close = isQualifiedJSXName(closingElement.name);
    if (open !== close) {
        this.tolerate(context, 1 /* UnexpectedToken */, close);
    }
    return this.parseJSXElement(context, children, openingElement, closingElement, pos);
};
Parser.prototype.parseJSXOpeningFragment = function parseJSXOpeningFragment (context, pos) {
    this.nextJSXToken();
    return this.finishNode(context, pos, {
        type: 'JSXOpeningFragment'
    });
};
Parser.prototype.parseJSXOpeningElement = function parseJSXOpeningElement (context, state, pos) {
    var tagName = this.parseJSXElementName(context);
    var attributes = this.parseJSXAttributes(context);
    if (this.token === 657216 /* GreaterThan */) {
        this.nextJSXToken();
    }
    else {
        this.expect(context, 657973 /* Divide */);
        this.expect(context, 657216 /* GreaterThan */);
        state |= 1 /* SelfClosing */;
    }
    return this.finishNode(context, pos, {
        type: 'JSXOpeningElement',
        name: tagName,
        attributes: attributes,
        selfClosing: !!(state & 1 /* SelfClosing */)
    });
};
Parser.prototype.parseJSXElement = function parseJSXElement (context, children, openingElement, closingElement, pos) {
        if ( children === void 0 ) children = [];

    return this.finishNode(context, pos, {
        type: 'JSXElement',
        children: children,
        openingElement: openingElement,
        closingElement: closingElement,
    });
};
Parser.prototype.parseFragment = function parseFragment (context, children, openingElement, closingElement, pos) {
    return this.finishNode(context, pos, {
        type: 'JSXFragment',
        children: children,
        openingElement: openingElement,
        closingElement: closingElement,
    });
};

var pluginClassCache = {};
function parse(source, context, options) {
    var sourceFile = '';
    var Cherow;
    var delegate;
    if (options != null) {
        if (options.source)
            { sourceFile = options.source; }
        if (typeof options.delegate === 'function') {
            delegate = options.delegate;
            context |= 128 /* OptionsDelegate */;
        }
        if (options.plugins) {
            var key = options.plugins.join('/');
            Cherow = pluginClassCache[key];
            if (!Cherow) {
                Cherow = Parser;
                for (var i = 0, list = options.plugins; i < list.length; i += 1) {
                    var plugin = list[i];

                    Cherow = plugin(Cherow);
                }
                pluginClassCache[key] = Cherow;
            }
            return new Cherow(source, sourceFile).parseProgram(context, options, delegate);
        }
    }
    return new Parser(source, sourceFile).parseProgram(context, options, delegate);
}
// https://tc39.github.io/ecma262/#sec-scripts
var parseScript = function (source, options) {
    return parse(source, 262144 /* TopLevel */, options);
};
// https://tc39.github.io/ecma262/#sec-modules
var parseModule = function (source, options) {
    return parse(source, 512 /* Strict */ | 1024 /* Module */ | 262144 /* TopLevel */, options);
};
var version = '1.3.6';

exports.parse = parse;
exports.parseScript = parseScript;
exports.parseModule = parseModule;
exports.version = version;

Object.defineProperty(exports, '__esModule', { value: true });

})));
